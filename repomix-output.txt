This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-30T10:00:12.823Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
__test__/
  test.tsx
  various.test.ts
.github/
  workflows/
    ci.yml
src/
  commands/
    _app.tsx
    apply.tsx
    build.tsx
    index.tsx
    init.tsx
    register.tsx
    watch.tsx
  components/
    TimeSince.tsx
  hooks/
    useTemplateState.ts
  lib/
    templateManager.test.ts
    templateManager.ts
  utils/
    applyMigration.ts
    calculateMD5.ts
    config.ts
    createEmptyBuildLog.ts
    db.connection.ts
    displayErrorSummary.ts
    ensureDirectories.ts
    fileExists.ts
    getMigrationFileHash.ts
    getNextTimestamp.ts
    getTimeAgo.ts
    isWipTemplate.ts
    loadBuildLog.ts
    logger.ts
    registerTemplate.ts
    safeCreate.ts
    saveBuildLog.ts
  cli.tsx
  constants.ts
  types.ts
supabase/
  migrations/
    20241229153624_tmpl-test.sql
  migrations-templates/
    .buildlog.json
    another.wip.sql
    new.wip.sql
    test.sql
  .gitignore
  config.toml
.editorconfig
.gitattributes
.gitignore
.npmignore
.prettierignore
.prettierrc.json
Ink UI readme.md
package.json
Pastel-readme.md
README.md
tsconfig.json
vitest.config.ts
vitest.setup.ts

================================================================
Files
================================================================

================
File: __test__/test.tsx
================
import React from 'react';
import chalk from 'chalk';
import { describe, test, expect } from 'vitest';
import { render } from 'ink-testing-library';
import Index from '../src/commands/index';

describe('Index component', () => {
  test('should greet user', () => {
    const { lastFrame } = render(<Index />);
    expect(lastFrame()).toBe(`Hello, ${chalk.green('Jane')}`);
  });
});

================
File: __test__/various.test.ts
================
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import path from 'path';

const files = vi.hoisted(() => new Map<string, string>());
const fsImpl = vi.hoisted(() => {
  return {
    default: {
      writeFile: vi.fn((path: string, content: string) => {
        files.set(path, content);
        return Promise.resolve();
      }),
      readFile: vi.fn((path: string) => {
        const content = files.get(path);
        return content ? Promise.resolve(content) : Promise.reject(new Error('File not found'));
      }),
      unlink: vi.fn(() => Promise.resolve()),
    },
  };
});

vi.mock('fs/promises', () => fsImpl);

import { loadBuildLog } from '../src/utils/loadBuildLog';
import { isWipTemplate } from '../src/utils/isWipTemplate';
import { saveBuildLog } from '../src/utils/saveBuildLog';
import { getNextTimestamp } from '../src/utils/getNextTimestamp';
import { calculateMD5 } from '../src/utils/calculateMD5';
import { BuildLog, CLIConfig } from '../src/types';
import { getConfig } from '../src/utils/config';

let config: CLIConfig;

const setup = async () => {
  config = await getConfig();
};
setup();

describe('Template Processing', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Skip console logs in testing
    vi.spyOn(console, 'log').mockImplementation(() => {});
    vi.spyOn(console, 'error').mockImplementation(() => {});
  });

  it('should detect WIP templates correctly', async () => {
    expect(await isWipTemplate('test.wip.sql')).toBe(true);
    expect(await isWipTemplate('test.sql')).toBe(false);
  });

  it('should calculate consistent hashes', async () => {
    const content = 'SELECT * FROM test;';
    const hash1 = await calculateMD5(content);
    const hash2 = await calculateMD5(content);
    expect(hash1).toBe(hash2);
  });

  it('should not overwrite existing migration files', async () => {
    const { migrationDir } = await getConfig();
    // Setup existing migration file
    const existingTimestamp = '20241125223247';
    const existingPath = path.join(migrationDir, `${existingTimestamp}_tmpl-test.sql`);
    const existingContent = 'existing content';
    files.set(existingPath, existingContent);

    // Setup build log with the same timestamp
    const buildLog = {
      templates: {},
      lastTimestamp: existingTimestamp,
      version: '1.0',
    } satisfies BuildLog;

    // Get next timestamp - should be different
    const newTimestamp = await getNextTimestamp(buildLog);

    // Assertions
    expect(newTimestamp).not.toBe(existingTimestamp);
    expect(BigInt(newTimestamp)).toBeGreaterThan(BigInt(existingTimestamp));
    expect(files.get(existingPath)).toBe(existingContent); // Original file unchanged
  });
});

describe('Build Logs', () => {
  const mockBuildLog = {
    version: '1.0',
    lastTimestamp: '20240101120000',
    templates: {
      'test.sql': {
        lastBuildHash: '123',
        lastBuildDate: '2024-01-01',
        lastMigrationFile: 'migration.sql',
      },
    },
  } satisfies BuildLog;

  const mockLocalBuildLog = {
    version: '1.0',
    lastTimestamp: '',
    templates: {
      'test.sql': {
        lastAppliedHash: '123',
        lastAppliedDate: '2024-12-25T07:07:37+00:00',
        lastMigrationFile: '',
      },
    },
  } satisfies BuildLog;

  beforeEach(() => {
    vi.clearAllMocks();
    files.clear();

    // Pre-populate mock filesystem with absolute paths
    files.set(path.resolve(__dirname, config.buildLog), JSON.stringify(mockBuildLog));
    files.set(path.resolve(__dirname, config.localBuildLog), JSON.stringify(mockLocalBuildLog));
  });

  afterEach(() => {
    files.clear();
  });

  it('should load build logs correctly', async () => {
    const buildLog = await loadBuildLog(__dirname, 'common');
    const localBuildLog = await loadBuildLog(__dirname, 'local');

    expect(buildLog).toEqual(mockBuildLog);
    expect(localBuildLog).toEqual(mockLocalBuildLog);
  });

  it('should handle missing build logs', async () => {
    files.clear();

    const buildLog = await loadBuildLog(__dirname, 'common');
    const localBuildLog = await loadBuildLog(__dirname, 'local');

    expect(buildLog).toEqual({ templates: {}, lastTimestamp: '', version: '1.0' });
    expect(localBuildLog).toEqual({ templates: {}, lastTimestamp: '', version: '1.0' });
  });

  it('should save build logs correctly', async () => {
    const newBuildLog = {
      templates: {
        'new.sql': {
          lastBuildHash: '456',
          lastBuildDate: '2024-01-02',
          lastMigrationFile: 'new-migration.sql',
        },
      },
      lastTimestamp: '20240102120000',
      version: '1.0',
    } satisfies BuildLog;

    const newLocalBuildLog = {
      templates: {
        'new.sql': {
          lastAppliedHash: '456',
          lastAppliedDate: '2024-01-02',
        },
      },
      lastTimestamp: '',
      version: '1.0',
    } satisfies BuildLog;

    await saveBuildLog(__dirname, newBuildLog, 'common');
    await saveBuildLog(__dirname, newLocalBuildLog, 'local');

    const savedBuildLog = JSON.parse(files.get(path.resolve(__dirname, config.buildLog)) || '');
    const savedLocalBuildLog = JSON.parse(
      files.get(path.resolve(__dirname, config.localBuildLog)) || ''
    );

    expect(savedBuildLog).toEqual(newBuildLog);
    expect(savedLocalBuildLog).toEqual(newLocalBuildLog);
  });

  it('should generate sequential timestamps', async () => {
    const buildLog = { templates: {}, lastTimestamp: '20240101120000', version: '1.0' };
    const timestamp1 = await getNextTimestamp(buildLog);
    const timestamp2 = await getNextTimestamp(buildLog);
    expect(BigInt(timestamp2)).toBeGreaterThan(BigInt(timestamp1));
  });

  it('should handle timestamp collisions', async () => {
    const buildLog = { templates: {}, lastTimestamp: '20240101120000', version: '1.0' };
    vi.setSystemTime(new Date('2024-01-01T11:59:59Z')); // Earlier than lastTimestamp

    const timestamp = await getNextTimestamp(buildLog);
    expect(timestamp).toBe('20240101120001'); // Should increment the last timestamp
    expect(buildLog.lastTimestamp).toBe('20240101120001');
  });

  it('should use current time when newer than last timestamp', async () => {
    const buildLog = { templates: {}, lastTimestamp: '20240101120000', version: '1.0' };
    vi.setSystemTime(new Date('2024-01-01T13:00:00Z')); // Later than lastTimestamp

    const timestamp = await getNextTimestamp(buildLog);
    expect(timestamp).toBe('20240101130000');
    expect(buildLog.lastTimestamp).toBe('20240101130000');
  });
});

================
File: .github/workflows/ci.yml
================
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 54322:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Type check
        run: npm run type-check

      - name: Lint
        run: npm run lint

      - name: Test
        run: npm run test
        env:
          CI: true
          POSTGRES_URL: postgresql://postgres:postgres@localhost:54322/postgres

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v3
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

================
File: src/commands/_app.tsx
================
import React from 'react';
import type { AppProps } from 'pastel';
import { Box } from 'ink';

export default function App({ Component, commandProps }: AppProps) {
  return (
    <Box flexDirection="column">
      <Component {...commandProps} />
    </Box>
  );
}

================
File: src/commands/apply.tsx
================
import React from 'react';
import { TemplateManager } from '../lib/templateManager.js';

export default function Apply() {
  React.useEffect(() => {
    async function doApply() {
      try {
        const manager = await TemplateManager.create(process.cwd());
        await manager.processTemplates({ apply: true });
        process.exit(0);
      } catch (err) {
        console.error('Error:', err instanceof Error ? err.message : String(err));
        process.exit(1);
      }
    }
    void doApply();
  }, []);
  return null;
}

================
File: src/commands/build.tsx
================
// commands/build.tsx
import React from 'react';
import { TemplateManager } from '../lib/templateManager.js';

export default function Build() {
  React.useEffect(() => {
    async function doBuild() {
      const manager = await TemplateManager.create(process.cwd());
      await manager.processTemplates({ generateFiles: true });
      process.exit(0);
    }
    doBuild();
  }, []);

  return null;
}

================
File: src/commands/index.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { Select } from '@inkjs/ui';
import Register from './register.js';
import Apply from './apply.js';
import Build from './build.js';
import Watch from './watch.js';

export default function UI() {
  const [selectedCommand, setSelectedCommand] = React.useState<string | null>(null);

  // For now, we only demonstrate navigation to "register"
  if (selectedCommand === 'register') {
    return <Register args={undefined} />;
  }

  if (selectedCommand === 'apply') {
    return <Apply />;
  }

  if (selectedCommand === 'build') {
    return <Build />;
  }

  if (selectedCommand === 'watch') {
    return <Watch />;
  }

  const menuItems = [
    { label: 'üèóÔ∏è  build - Build Supabase migrations from templates', value: 'build' },
    { label: '‚ñ∂Ô∏è  apply - Apply migration templates directly to database', value: 'apply' },
    { label: '‚úçÔ∏è  register - Register templates as already built', value: 'register' },
    {
      label: 'üëÄ  watch - Watch templates for changes and apply directly to database',
      value: 'watch',
    },
  ];

  return (
    <Box flexDirection="column">
      <Text bold>srtd - Repeatable Template SQL Migration Tool</Text>
      <Text>Select a command:</Text>
      <Box marginTop={1}>
        <Select options={menuItems} onChange={value => setSelectedCommand(value)} />
      </Box>
    </Box>
  );
}

================
File: src/commands/init.tsx
================
import React from 'react';
import fs from 'fs/promises';
import path from 'path';
import { getConfig, saveConfig } from '../utils/config.js';
import { CONFIG_FILE } from '../constants.js';
import { createEmptyBuildLog } from '../utils/createEmptyBuildLog.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';
import { fileExists } from '../utils/fileExists.js';

export default function Init() {
  React.useEffect(() => {
    async function doInit() {
      try {
        const baseDir = process.cwd();
        const config = await getConfig(baseDir);
        const configPath = path.join(baseDir, CONFIG_FILE);

        if (await fileExists(configPath)) {
          console.log(`‚è≠Ô∏è ${CONFIG_FILE} already exists`);
        } else {
          await saveConfig(baseDir, {});
          console.log(`‚úÖ Created ${CONFIG_FILE} with default configuration`);
        }

        const dirs = await ensureDirectories(baseDir);
        if (dirs.templateDir) {
          console.log('‚úÖ Created template directory');
        } else {
          console.log('‚è≠Ô∏è Template directory already exists');
        }
        if (dirs.migrationDir) {
          console.log('‚úÖ Created migration directory');
        } else {
          console.log('‚è≠Ô∏è Migration directory already exists');
        }

        const buildLogCreated = await createEmptyBuildLog(path.join(baseDir, config.buildLog));
        const localBuildLogCreated = await createEmptyBuildLog(
          path.join(baseDir, config.localBuildLog)
        );

        if (buildLogCreated) console.log('‚úÖ Created build log');
        if (localBuildLogCreated) console.log('‚úÖ Created local build log');

        const gitignorePath = path.join(baseDir, '.gitignore');
        const ignoreEntry = config.localBuildLog;

        let content = '';
        try {
          content = await fs.readFile(gitignorePath, 'utf-8');
        } catch {
          // Ignore
        }

        if (!content.includes(ignoreEntry)) {
          content = content.trim() + '\n' + ignoreEntry + '\n';
          await fs.writeFile(gitignorePath, content);
          console.log('‚úÖ Updated .gitignore');
        } else {
          console.log('‚è≠Ô∏è .gitignore already updated');
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize:', error);
        process.exit(1);
      }
    }
    doInit();
  }, []);

  return null;
}

================
File: src/commands/register.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { MultiSelect } from '@inkjs/ui';
import { useTemplateState } from '../hooks/useTemplateState.js';
import { registerTemplate } from '../utils/registerTemplate.js';
import { argument } from 'pastel';
import zod from 'zod';

// Support both array of filenames as arguments and interactive selection
export const args = zod
  .array(zod.string())
  .optional()
  .describe(
    argument({
      name: 'templates',
      description: 'Template files to register (optional)',
    })
  );

type Props = {
  args: zod.infer<typeof args>;
};

export default function Register({ args: templateArgs }: Props) {
  const { error, items } = useTemplateState();
  const [selectedValues, setSelectedValues] = React.useState<string[]>([]);
  const [successMessage, setSuccessMessage] = React.useState('');
  const [errorMessage, setErrorMessage] = React.useState('');

  const handleTemplateRegistration = React.useCallback(async (templates: string[]) => {
    setSuccessMessage('');
    setErrorMessage('');

    let successCount = 0;
    let failCount = 0;

    for (const path of templates) {
      try {
        await registerTemplate(path, process.cwd());
        successCount++;
      } catch {
        failCount++;
      }
    }

    if (failCount > 0) {
      setErrorMessage(`Failed to register ${failCount} template(s).`);
    }
    if (successCount > 0) {
      setSuccessMessage(`Successfully registered ${successCount} template(s).`);
    }

    process.exit(failCount > 0 ? 1 : 0);
  }, []);

  React.useEffect(() => {
    // If templates were provided as arguments, register them directly
    if (templateArgs?.length) {
      void handleTemplateRegistration(templateArgs);
    }
  }, [handleTemplateRegistration, templateArgs]);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  // If no templates were provided as arguments, show interactive selection
  if (!templateArgs?.length) {
    const options = items.map(t => {
      const status = t.buildState.lastMigrationFile ? 'registered' : 'new';
      return {
        label: `${t.name} (${status})`,
        value: t.path,
      };
    });

    return (
      <Box flexDirection="column">
        <Text bold>Register Templates</Text>
        <Text>Use arrow/space to select, then press Enter to register.</Text>
        <Box marginTop={1}>
          <Text color="white">
            {selectedValues.length} / {options.length} selected
          </Text>
        </Box>
        <Box marginTop={1} marginBottom={1}>
          <MultiSelect
            options={options}
            onChange={vals => setSelectedValues(vals)}
            onSubmit={vals => void handleTemplateRegistration(vals)}
          />
        </Box>
        {!!errorMessage && <Text color="red">{errorMessage}</Text>}
        {!!successMessage && <Text color="green">{successMessage}</Text>}
      </Box>
    );
  }

  return (
    <Box flexDirection="column" marginTop={1}>
      {!!errorMessage && <Text color="red">{errorMessage}</Text>}
      {!!successMessage && <Text color="green">{successMessage}</Text>}
    </Box>
  );
}

================
File: src/commands/watch.tsx
================
import React from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import path from 'path';
import { TemplateManager } from '../lib/templateManager.js';
import type { TemplateStatus } from '../types.js';
import { TimeSince } from '../components/TimeSince.js';

export default function Watch() {
  const { exit } = useApp();
  const [templates, setTemplates] = React.useState<TemplateStatus[]>([]);
  const [error, setError] = React.useState<string>();
  const managerRef = React.useRef<TemplateManager>();
  const mounted = React.useRef(true);

  useInput((input, key) => {
    if (input.toLowerCase() === 'q' || (key.ctrl && input === 'c')) {
      mounted.current = false;
      setTimeout(() => exit(), 0);
    }
  });

  React.useEffect(() => {
    let cleanup: (() => void) | undefined;
    console.clear();

    async function init(): Promise<() => void> {
      try {
        managerRef.current = await TemplateManager.create(process.cwd(), { silent: true });

        // Initial template load
        const initialTemplates = await managerRef.current.findTemplates();
        for (const templatePath of initialTemplates) {
          const status = await managerRef.current.getTemplateStatus(templatePath);
          if (mounted.current) {
            setTemplates(prev => [...prev.filter(t => t.path !== status.path), status]);
          }
        }

        // Watch and handle changes
        const watcher = await managerRef.current.watch();

        // Update UI on template changes
        const updateTemplate = async (template: TemplateStatus) => {
          if (!mounted.current) return;
          const status = await managerRef.current?.getTemplateStatus(template.path);
          if (status) {
            setTemplates(prev => [...prev.filter(t => t.path !== status.path), status]);
          }
        };

        managerRef.current.on('templateChanged', updateTemplate);
        managerRef.current.on('templateApplied', updateTemplate);
        managerRef.current.on('templateError', ({ template }) => updateTemplate(template));

        // Initial apply for any out-of-date templates
        await managerRef.current.processTemplates({ apply: true });

        return () => {
          mounted.current = false;
          watcher.close();
        };
      } catch (err) {
        if (mounted.current) {
          setError(err instanceof Error ? err.message : String(err));
        }
        return () => {
          mounted.current = false;
        };
      }
    }

    init().then(c => (cleanup = c));
    return () => cleanup?.();
  }, []);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  const templatesByDir = templates.reduce(
    (acc, template) => {
      const dir = path.dirname(path.relative(process.cwd(), template.path));
      (acc[dir] = acc[dir] || []).push(template);
      return acc;
    },
    {} as Record<string, TemplateStatus[]>
  );

  const hasErrors = templates.some(t => t.buildState.lastAppliedError);

  return (
    <Box flexDirection="column" marginBottom={2} marginTop={2}>
      <Box marginBottom={1}>
        <Text bold>srtd - Watch Mode</Text>
      </Box>

      {Object.entries(templatesByDir).map(([dir, dirTemplates]) => (
        <Box key={dir} flexDirection="column" marginLeft={1}>
          <Text dimColor>{dir}</Text>
          {dirTemplates.map(template => (
            <Box key={template.path} marginLeft={2}>
              <Box width={2}>
                <Text>
                  {template.buildState.lastAppliedError
                    ? '‚ùå'
                    : template === templates[templates.length - 1]
                      ? '‚úì'
                      : ' '}
                </Text>
              </Box>
              <Box width={20}>
                <Text>{path.basename(template.path)}</Text>
              </Box>
              <Box>
                <Text dimColor>
                  applied <TimeSince date={template.buildState.lastAppliedDate} /> ago
                  {!template.buildState.lastBuildDate ||
                  template.currentHash !== template.buildState.lastBuildHash ? (
                    <> ‚Ä¢ needs build</>
                  ) : (
                    <>
                      {' '}
                      ‚Ä¢ built <TimeSince date={template.buildState.lastBuildDate} /> ago
                    </>
                  )}
                </Text>
              </Box>
            </Box>
          ))}
        </Box>
      ))}

      {hasErrors && (
        <Box flexDirection="column" marginY={1}>
          <Text bold color="red">
            Errors
          </Text>
          {templates
            .filter(t => t.buildState.lastAppliedError)
            .map(t => (
              <Box key={t.name} marginLeft={2}>
                <Text color="red">
                  ‚Ä¢ {t.name}: {t.buildState.lastAppliedError}
                </Text>
              </Box>
            ))}
        </Box>
      )}

      <Box marginY={1}>
        <Text bold backgroundColor={hasErrors ? 'red' : 'green'}>
          {hasErrors ? ' FAIL ' : ' OK '}
        </Text>
        <Text> </Text>
        <Text dimColor>Watching for template changes...</Text>
      </Box>

      <Box>
        <Text dimColor>press </Text>
        <Text>q</Text>
        <Text dimColor> or </Text>
        <Text>Ctrl+c</Text>
        <Text dimColor> to quit</Text>
      </Box>
    </Box>
  );
}

================
File: src/components/TimeSince.tsx
================
import React from 'react';
import { Text } from 'ink';

export const TimeSince: React.FC<{ date?: string }> = ({ date }) => {
  const [now, setNow] = React.useState(new Date());

  React.useEffect(() => {
    const timer = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);

  if (!date) return <Text>never</Text>;

  const diff = now.getTime() - new Date(date).getTime();
  const seconds = Math.floor(diff / 1000);

  if (seconds < 60) return <Text>{seconds}s</Text>;
  if (seconds < 3600) return <Text>{Math.floor(seconds / 60)}m</Text>;
  if (seconds < 86400) return <Text>{Math.floor(seconds / 3600)}h</Text>;
  return <Text>{Math.floor(seconds / 86400)}d</Text>;
};

================
File: src/hooks/useTemplateState.ts
================
// hooks/useTemplateState.ts
import { useState, useEffect } from 'react';
import { TemplateStatus } from '../types.js';
import { TemplateManager } from '../lib/templateManager.js';

export function useTemplateState() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<TemplateStatus[]>([]);

  useEffect(() => {
    async function fetchStatus() {
      try {
        const baseDir = process.cwd();
        const manager = await TemplateManager.create(baseDir);
        const templates = await manager.findTemplates();
        const statuses = await Promise.all(templates.map(t => manager.getTemplateStatus(t)));
        setItems(statuses);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  return { loading, error, items };
}

================
File: src/lib/templateManager.test.ts
================
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { tmpdir } from 'os';
import { join } from 'path';
import fs from 'fs/promises';
import { TemplateManager } from './templateManager.js';
import { connect, disconnect } from '../utils/db.connection.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';

describe('TemplateManager', () => {
  const testContext = {
    timestamp: Date.now(),
    testDir: '',
    testFunctionName: '',
  };

  beforeEach(async () => {
    testContext.testDir = join(tmpdir(), `srtd-test-${testContext.timestamp}`);
    testContext.testFunctionName = `test_func_${testContext.timestamp}`;

    await ensureDirectories(testContext.testDir);

    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testContext.testFunctionName}()`);
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }
  });

  afterEach(async () => {
    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testContext.testFunctionName}()`);
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
    } finally {
      client.release();
    }

    await fs.rm(testContext.testDir, { recursive: true, force: true });
    await disconnect();
  });

  const createTemplate = async (name: string, content: string) => {
    const path = join(testContext.testDir, 'test-templates', name);
    await fs.writeFile(path, content);
    return path;
  };

  const createTemplateWithFunc = async (name: string, funcSuffix = '') => {
    const funcName = `${testContext.testFunctionName}${funcSuffix}`;
    const content = `CREATE FUNCTION ${funcName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;
    return createTemplate(name, content);
  };

  it('should handle concurrent template operations', async () => {
    const templates = await Promise.all(
      [...Array(5)].map((_, i) =>
        createTemplateWithFunc(`test-${i}-${testContext.timestamp}.sql`, `_${i}`)
      )
    );

    const manager = await TemplateManager.create(testContext.testDir);

    // Apply templates one by one
    for (const templatePath of templates) {
      const result = await manager.processTemplates({ apply: true });
      expect(result.errors).toHaveLength(0);
    }

    const client = await connect();
    try {
      for (let i = 0; i < 5; i++) {
        const res = await client.query(`SELECT proname FROM pg_proc WHERE proname = $1`, [
          `${testContext.testFunctionName}_${i}`,
        ]);
        expect(res.rows).toHaveLength(1);
      }
    } finally {
      client.release();
    }
  });

  it('should handle database disconnections gracefully', async () => {
    await createTemplateWithFunc(`test-${testContext.timestamp}.sql`);
    const manager = await TemplateManager.create(testContext.testDir);

    // Force pool to recreate
    await disconnect();
    const client = await connect();
    await client.query('SELECT pg_terminate_backend(pg_backend_pid())');
    client.release();

    const result = await manager.processTemplates({ apply: true });
    expect(result.errors.length).toBeGreaterThan(0);
  });

  it('should handle rapid template modifications during build', async () => {
    const templatePath = await createTemplateWithFunc(`test-${testContext.timestamp}.sql`);
    const manager = await TemplateManager.create(testContext.testDir);

    // Start build process
    const buildPromise = manager.processTemplates({ generateFiles: true });

    // Give build a chance to read original content
    await new Promise(resolve => setTimeout(resolve, 100));
    await fs.writeFile(templatePath, 'MODIFIED CONTENT');

    await buildPromise;

    const migrations = await fs.readdir(join(testContext.testDir, 'test-migrations'));
    expect(migrations.length).toBeGreaterThan(0);
    const content = await fs.readFile(
      join(testContext.testDir, 'test-migrations', migrations[0]!),
      'utf-8'
    );
    expect(content).toContain(testContext.testFunctionName);
  });
});

================
File: src/lib/templateManager.ts
================
import fs from 'fs/promises';
import glob from 'glob';
import path from 'path';
import EventEmitter from 'events';
import { calculateMD5 } from '../utils/calculateMD5.js';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { saveBuildLog } from '../utils/saveBuildLog.js';
import { getConfig } from '../utils/config.js';
import { isWipTemplate } from '../utils/isWipTemplate.js';
import { applyMigration } from '../utils/applyMigration.js';
import { getNextTimestamp } from '../utils/getNextTimestamp.js';
import { logger } from '../utils/logger.js';
import type { BuildLog, TemplateStatus, CLIResult } from '../types.js';

interface TemplateCache {
  status: TemplateStatus;
  lastChecked: number;
}

export class TemplateManager extends EventEmitter {
  private baseDir: string;
  private buildLog: BuildLog;
  private localBuildLog: BuildLog;
  private config: Awaited<ReturnType<typeof getConfig>>;
  private templateCache: Map<string, TemplateCache> = new Map();
  private cacheTimeout = 1000;
  private silent: boolean;

  // Constructor:
  private constructor(
    baseDir: string,
    buildLog: BuildLog,
    localBuildLog: BuildLog,
    config: Awaited<ReturnType<typeof getConfig>>,
    options: { silent?: boolean } = {}
  ) {
    super();
    this.silent = options.silent ?? false;
    this.baseDir = baseDir;
    this.buildLog = buildLog;
    this.localBuildLog = localBuildLog;
    this.config = config;
  }

  static async create(baseDir: string, options: { silent?: boolean } = {}) {
    const config = await getConfig(baseDir);
    const buildLog = await loadBuildLog(baseDir, 'common');
    const localBuildLog = await loadBuildLog(baseDir, 'local');
    return new TemplateManager(baseDir, buildLog, localBuildLog, config, options);
  }

  private isCacheValid(cache: TemplateCache): boolean {
    return Date.now() - cache.lastChecked < this.cacheTimeout;
  }

  private invalidateCache(templatePath: string) {
    this.templateCache.delete(templatePath);
  }

  async findTemplates(): Promise<string[]> {
    const templatePath = path.join(this.baseDir, this.config.templateDir, this.config.filter);
    return new Promise((resolve, reject) => {
      glob(templatePath, (err, matches) => {
        if (err) reject(err);
        else resolve(matches);
      });
    });
  }

  async getTemplateStatus(templatePath: string): Promise<TemplateStatus> {
    const cached = this.templateCache.get(templatePath);
    if (cached && this.isCacheValid(cached)) {
      return cached.status;
    }

    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const relPath = path.relative(this.baseDir, templatePath);

    // Merge build and apply states
    const buildState = {
      ...this.buildLog.templates[relPath],
      ...this.localBuildLog.templates[relPath],
    };

    const status = {
      name: path.basename(templatePath, '.sql'),
      path: templatePath,
      currentHash,
      migrationHash: null,
      buildState,
    };

    this.templateCache.set(templatePath, {
      status,
      lastChecked: Date.now(),
    });

    return status;
  }

  private async saveBuildLogs(): Promise<void> {
    await Promise.all([
      saveBuildLog(this.baseDir, this.buildLog, 'common'),
      saveBuildLog(this.baseDir, this.localBuildLog, 'local'),
    ]);
  }

  private async handleTemplateChange(templatePath: string): Promise<void> {
    this.invalidateCache(templatePath);
    const template = await this.getTemplateStatus(templatePath);
    this.emit('templateChanged', template);

    const result = await this.applyTemplate(templatePath);
    if (result.errors.length) {
      this.emit('templateError', {
        template,
        error: result.errors[0],
      });
    } else {
      const updatedTemplate = await this.getTemplateStatus(templatePath);
      this.emit('templateApplied', updatedTemplate);
    }
  }

  async watch(): Promise<{ close: () => void }> {
    const chokidar = await import('chokidar');
    const templatePath = path.join(this.baseDir, this.config.templateDir);

    const watcher = chokidar.watch(templatePath, {
      ignoreInitial: true,
      depth: 0,
      ignored: /(^|[\\])\../,
    });

    watcher.on('change', async (filepath: string) => {
      if (path.extname(filepath) === '.sql') {
        await this.handleTemplateChange(filepath);
      }
    });

    return watcher;
  }

  async applyTemplate(templatePath: string): Promise<CLIResult> {
    const template = await this.getTemplateStatus(templatePath);
    const content = await fs.readFile(templatePath, 'utf-8');
    const result = await applyMigration(content, template.name, this.silent);
    const relPath = path.relative(this.baseDir, templatePath);

    this.invalidateCache(templatePath);

    if (result === true) {
      this.localBuildLog.templates[relPath] = {
        ...this.localBuildLog.templates[relPath],
        lastAppliedHash: template.currentHash,
        lastAppliedDate: new Date().toISOString(),
        lastAppliedError: undefined,
      };
      await this.saveBuildLogs();
      this.emit('templateApplied', template);
      return { errors: [], applied: [template.name] };
    }

    this.localBuildLog.templates[relPath] = {
      ...this.localBuildLog.templates[relPath],
      lastAppliedError: result.error,
    };
    await this.saveBuildLogs();
    this.emit('templateError', { template, error: result });
    return { errors: [result], applied: [] };
  }

  async buildTemplate(templatePath: string, force = false): Promise<void> {
    const template = await this.getTemplateStatus(templatePath);
    const isWip = await isWipTemplate(templatePath);
    const relPath = path.relative(this.baseDir, templatePath);

    if (isWip) {
      this.log(`Skipping WIP template: ${template.name}`, 'skip');
      return;
    }

    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);

    if (!force && this.buildLog.templates[relPath]?.lastBuildHash === currentHash) {
      this.log(`Skipping unchanged template: ${template.name}`, 'skip');
      return;
    }

    const timestamp = await getNextTimestamp(this.buildLog);
    const migrationName = `${timestamp}_tmpl-${template.name}.sql`;
    const migrationPath = path.join(this.config.migrationDir, migrationName);

    const header = `-- Generated from template: ${this.config.templateDir}/${template.name}.sql\n`;
    const banner = this.config.banner ? `-- ${this.config.banner}\n` : '\n';
    const footer = `${this.config.footer}\n-- Last built: ${
      this.buildLog.templates[relPath]?.lastBuildDate || 'Never'
    }`;

    const safeContent = this.config.wrapInTransaction ? `BEGIN;\n${content}\nCOMMIT;` : content;
    const migrationContent = `${header}${banner}\n${safeContent}\n${footer}`;

    await fs.writeFile(path.resolve(this.baseDir, migrationPath), migrationContent);

    this.buildLog.templates[relPath] = {
      ...this.buildLog.templates[relPath],
      lastBuildHash: currentHash,
      lastBuildDate: new Date().toISOString(),
      lastMigrationFile: migrationName,
      lastBuildError: undefined,
    };

    this.invalidateCache(templatePath);
    await this.saveBuildLogs();
    this.emit('templateBuilt', template);
  }

  private log(msg: string, type: 'info' | 'error' | 'success' | 'skip' = 'info') {
    if (this.silent) return;
    if (type === 'error') logger.error(msg);
    else if (type === 'success') logger.success(msg);
    else if (type === 'skip') logger.skip(msg);
    else logger.info(msg);
  }
  async processTemplates(options: {
    apply?: boolean;
    generateFiles?: boolean;
    force?: boolean;
  }): Promise<CLIResult> {
    const templates = await this.findTemplates();
    const result: CLIResult = { errors: [], applied: [] };

    if (options.apply) {
      this.log('Applying changes...');
      let hasChanges = false;

      for (const templatePath of templates) {
        const template = await this.getTemplateStatus(templatePath);
        const needsApply =
          !template.buildState.lastAppliedHash ||
          template.buildState.lastAppliedHash !== template.currentHash;

        if (needsApply) {
          hasChanges = true;
          const applyResult = await this.applyTemplate(templatePath);
          result.errors.push(...applyResult.errors);
          result.applied.push(...applyResult.applied);
        }
      }

      if (!hasChanges) {
        this.log('No changes to apply');
      } else if (result.errors.length > 0) {
        this.log(`${result.errors.length} template(s) failed to apply`, 'error');
        result.errors.forEach(err => this.log(`${err.file}: ${err.error}`, 'error'));
      } else {
        this.log(`Applied ${result.applied.length} template(s)`, 'success');
      }
    }

    if (options.generateFiles) {
      let built = 0;
      let skipped = 0;

      for (const templatePath of templates) {
        const isWip = await isWipTemplate(templatePath);
        if (!isWip) {
          const template = await this.getTemplateStatus(templatePath);
          if (options.force || template.currentHash !== template.buildState.lastBuildHash) {
            await this.buildTemplate(templatePath, options.force);
            built++;
          } else {
            skipped++;
          }
        }
      }

      if (built > 0) {
        this.log(`Generated ${built} migration file(s)`, 'success');
      } else if (skipped > 0) {
        this.log('No changes to build');
      }
    }

    return result;
  }
}

================
File: src/utils/applyMigration.ts
================
import { MigrationError } from '../types.js';
import { connect } from './db.connection.js';
import { logger } from './logger.js';

export async function applyMigration(
  content: string,
  templateName: string,
  silent: boolean = false
): Promise<true | MigrationError> {
  const client = await connect();
  try {
    await client.query('BEGIN');
    const lockKey = Math.abs(Buffer.from(templateName).reduce((acc, byte) => acc + byte, 0));
    await client.query(`SELECT pg_advisory_xact_lock(${lockKey}::bigint)`);
    await client.query(content);
    await client.query('COMMIT');
    if (!silent) logger.success('Migration applied successfully');
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    if (!silent) logger.error(`Migration failed for ${templateName}: ${error}`);
    return {
      file: templateName,
      error: error instanceof Error ? error.message : String(error),
      templateName,
    };
  } finally {
    client.release();
  }
}

================
File: src/utils/calculateMD5.ts
================
import crypto from 'crypto';

export async function calculateMD5(content: string): Promise<string> {
  return crypto.createHash('md5').update(content).digest('hex');
}

================
File: src/utils/config.ts
================
import { CLIConfig } from '../types.js';
import path from 'path';
import fs from 'fs/promises';
import { CONFIG_FILE } from '../constants.js';

const defaultConfig: CLIConfig = {
  wipIndicator: '.wip',
  filter: '**/*.sql',
  banner: 'You very likely **DO NOT** want to manually edit this generated file.',
  footer: '',
  wrapInTransaction: true,
  templateDir: 'supabase/migrations-templates',
  migrationDir: 'supabase/migrations',
  buildLog: 'supabase/migrations-templates/.buildlog.json',
  localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
  pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
};

let cachedConfig: CLIConfig | undefined;

export async function getConfig(dir: string = process.cwd()): Promise<CLIConfig> {
  if (cachedConfig) return cachedConfig;

  try {
    const configPath = path.join(dir, CONFIG_FILE);
    const content = await fs.readFile(configPath, 'utf-8');
    cachedConfig = { ...defaultConfig, ...JSON.parse(content) };
  } catch {
    cachedConfig = defaultConfig;
  }

  return cachedConfig!;
}

export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
  const configPath = path.join(baseDir, CONFIG_FILE);
  const finalConfig = { ...defaultConfig, ...config };
  await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
  cachedConfig = finalConfig;
}

// import { CLIConfig } from '../types.js';
// import path from 'path';
// import fs from 'fs/promises';
// import { CONFIG_FILE } from '../constants.js';

// let config: CLIConfig;

// export async function getConfig(baseDir: string): Promise<CLIConfig> {
//   if (!config) {
//     config = await getConfig(baseDir);
//   }
//   return config;
// }

// const defaultConfig: CLIConfig = {
//   wipIndicator: '.wip',
//   filter: '**/*.sql',
//   banner: 'You very likely **DO NOT** want to manually edit this generated file.',
//   footer: '',
//   wrapInTransaction: true,
//   templateDir: 'supabase/migrations-templates',
//   migrationDir: 'supabase/migrations',
//   buildLog: 'supabase/migrations-templates/.buildlog.json',
//   localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
//   pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
// };

// export async function getConfig(dir?: string): Promise<CLIConfig> {
//   const baseDir = dir || process.cwd();
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   try {
//     const content = await fs.readFile(configPath, 'utf-8');
//     const userConfig = JSON.parse(content);
//     return { ...defaultConfig, ...userConfig };
//   } catch {
//     return defaultConfig;
//   }
// }

// export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   const finalConfig = { ...defaultConfig, ...config };
//   await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
// }

================
File: src/utils/createEmptyBuildLog.ts
================
import { BuildLog } from '../types.js';
import { safeCreate } from './safeCreate.js';

export async function createEmptyBuildLog(filepath: string): Promise<boolean> {
  const initial = {
    version: '1.0',
    lastTimestamp: '',
    templates: {},
  } satisfies BuildLog;
  return safeCreate(filepath, JSON.stringify(initial, null, 2));
}

================
File: src/utils/db.connection.ts
================
// utils/db.connection.ts
import pg from 'pg';
import { getConfig } from './config.js';
import { logger } from './logger.js';

let pool: pg.Pool | undefined;
let connectionAttempts = 0;
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

async function createPool(): Promise<pg.Pool> {
  const config = await getConfig(process.cwd());
  return new pg.Pool({
    connectionString: config.pgConnection,
    connectionTimeoutMillis: 5000,
  });
}

async function retryConnection(): Promise<pg.PoolClient> {
  connectionAttempts++;
  logger.debug(`Connection attempt ${connectionAttempts}`);

  try {
    if (!pool) pool = await createPool();
    return await pool.connect();
  } catch (err) {
    if (connectionAttempts < MAX_RETRIES) {
      logger.warn(`Connection failed, retrying in ${RETRY_DELAY}ms...`);
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
      return retryConnection();
    }
    throw new Error(`Database connection failed after ${MAX_RETRIES} attempts: ${err}`);
  }
}

export async function connect(): Promise<pg.PoolClient> {
  connectionAttempts = 0;
  return retryConnection();
}

export async function disconnect(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = undefined;
  }
}

process.on('exit', async () => await disconnect());

================
File: src/utils/displayErrorSummary.ts
================
import chalk from 'chalk';
import { MigrationError } from '../types.js';

export function displayErrorSummary(errors: MigrationError[]): void {
  if (errors.length === 0) return;

  console.log('\n  ‚ùå Error Summary:');
  console.log('  ================');
  errors.forEach(({ templateName, error }) => {
    console.log(`\n  Failed migration: ${chalk.red(templateName)}`);
    console.log(`  ${error.split('\n').join('\n  ')}`);
  });
  console.log('\n  ‚ö†Ô∏è  Some migrations failed. Please check the errors above.');
}

================
File: src/utils/ensureDirectories.ts
================
// utils/ensureDirectories.ts
import fs from 'fs/promises';
import path from 'path';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function ensureDirectories(
  baseDir: string
): Promise<{ templateDir: boolean; migrationDir: boolean }> {
  const config = await getConfig(baseDir);
  const templatePath = path.join(baseDir, config.templateDir);
  const migrationPath = path.join(baseDir, config.migrationDir);

  const templateExists = await fileExists(templatePath);
  const migrationExists = await fileExists(migrationPath);

  if (!templateExists) {
    await fs.mkdir(templatePath, { recursive: true });
  }

  if (!migrationExists) {
    await fs.mkdir(migrationPath, { recursive: true });
  }

  return {
    templateDir: !templateExists,
    migrationDir: !migrationExists,
  };
}

================
File: src/utils/fileExists.ts
================
import fs from 'fs/promises';

export async function fileExists(filepath: string): Promise<boolean> {
  try {
    await fs.access(filepath);
    return true;
  } catch {
    return false;
  }
}

================
File: src/utils/getMigrationFileHash.ts
================
import fs from 'fs/promises';
import path from 'path';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';

export async function getMigrationFileHash(
  migrationFile: string,
  baseDir: string
): Promise<string | null> {
  try {
    const config = await getConfig();
    const fullPath = path.join(baseDir, config.migrationDir, migrationFile);
    const content = await fs.readFile(fullPath, 'utf-8');
    return calculateMD5(content);
  } catch {
    return null;
  }
}

================
File: src/utils/getNextTimestamp.ts
================
import { BuildLog } from '../types.js';

export async function getNextTimestamp(buildLog: BuildLog): Promise<string> {
  const now = new Date();
  const timestamp = now.toISOString().replace(/\D/g, '').slice(0, 14);

  if (timestamp <= buildLog.lastTimestamp) {
    const nextTimestamp = (BigInt(buildLog.lastTimestamp) + 1n).toString();
    buildLog.lastTimestamp = nextTimestamp;
    return nextTimestamp;
  }

  buildLog.lastTimestamp = timestamp;
  return timestamp;
}

================
File: src/utils/getTimeAgo.ts
================
export function getTimeAgo(date: Date): string {
  const now = new Date();
  const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (seconds < 60) return 'just now';
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

================
File: src/utils/isWipTemplate.ts
================
import { getConfig } from './config.js';

export async function isWipTemplate(templatePath: string): Promise<boolean> {
  const config = await getConfig();
  return templatePath.includes(config.wipIndicator);
}

================
File: src/utils/loadBuildLog.ts
================
//utils/loadBuildLog.ts
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function loadBuildLog(dirname: string, which: 'local' | 'common'): Promise<BuildLog> {
  try {
    const config = await getConfig(dirname);
    const logPath = which === 'local' ? config.localBuildLog : config.buildLog;
    const content = await fs.readFile(path.resolve(dirname, logPath), 'utf-8');
    const log = JSON.parse(content);
    return {
      version: log.version || '1.0',
      lastTimestamp: log.lastTimestamp || '',
      templates: log.templates || {},
    };
  } catch {
    return { version: '1.0', templates: {}, lastTimestamp: '' };
  }
}

================
File: src/utils/logger.ts
================
// utils/logger.ts
import chalk from 'chalk';

export const logger = {
  info: (msg: string) => console.log(`  ${msg}`),
  success: (msg: string) => console.log(`  ‚úÖ ${chalk.green(msg)}`),
  warn: (msg: string) => console.log(`  ‚ö†Ô∏è  ${chalk.yellow(msg)}`),
  error: (msg: string) => console.log(`  ‚ùå ${chalk.red(msg)}`),
  skip: (msg: string) => console.log(`  ‚è≠Ô∏è  ${chalk.dim(msg)}`),
  debug: (msg: string) =>
    process.env['DEBUG'] &&
    process.env['DEBUG'] == 'true' &&
    console.log(`  üîç ${chalk.white(msg)}`),
};

================
File: src/utils/registerTemplate.ts
================
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from './loadBuildLog.js';
import { saveBuildLog } from './saveBuildLog.js';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function registerTemplate(templatePath: string, baseDir: string): Promise<void> {
  const config = await getConfig(baseDir);

  // Try multiple path resolutions
  const pathsToTry = [
    templatePath, // As provided
    path.join(baseDir, config.templateDir, templatePath), // In templates dir
  ];

  let resolvedPath: string | null = null;
  for (const p of pathsToTry) {
    if (await fileExists(p)) {
      resolvedPath = p;
      break;
    }
  }

  if (!resolvedPath) {
    console.log(chalk.red('Error:'), `Template file not found. Tried:`);
    for (const p of pathsToTry) {
      console.log(chalk.dim(`  - ${p}`));
    }
    throw new Error(`Template ${templatePath} not found`);
  }

  const content = await fs.readFile(resolvedPath, 'utf-8');
  const hash = await calculateMD5(content);
  const relativePath = path.relative(baseDir, resolvedPath);
  const now = new Date().toISOString();

  // Update build log
  const buildLog = await loadBuildLog(baseDir, 'common');
  buildLog.templates[relativePath] = {
    lastBuildHash: hash,
    lastBuildDate: now,
    lastMigrationFile: ``, // Unknown, may want to allow entering this?
  };

  await saveBuildLog(baseDir, buildLog, 'common');
  console.log(chalk.green(`‚úì Registered template:`), relativePath);
}

================
File: src/utils/safeCreate.ts
================
import fs from 'fs/promises';
import { fileExists } from './fileExists.js';

export async function safeCreate(filepath: string, content: string): Promise<boolean> {
  if (await fileExists(filepath)) {
    return false;
  }
  await fs.writeFile(filepath, content);
  return true;
}

================
File: src/utils/saveBuildLog.ts
================
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function saveBuildLog(
  dirname: string,
  log: BuildLog,
  which: 'local' | 'common'
): Promise<void> {
  const config = await getConfig();
  const useLog = which === 'local' ? config.localBuildLog : config.buildLog;
  await fs.writeFile(path.resolve(dirname, useLog), JSON.stringify(log, null, 2));
}

================
File: src/cli.tsx
================
#!/usr/bin/env node
import Pastel from 'pastel';

const app = new Pastel({
  importMeta: import.meta,
});

await app.run();

================
File: src/constants.ts
================
export const CONFIG_FILE = '.srtdrc.json';

================
File: src/types.ts
================
// types.ts
export interface TemplateBuildState {
  lastBuildHash?: string;
  lastBuildDate?: string;
  lastBuildError?: string;
  lastMigrationFile?: string;
  lastAppliedHash?: string;
  lastAppliedDate?: string;
  lastAppliedError?: string;
}

export interface BuildLog {
  version: string;
  lastTimestamp: string;
  templates: {
    [templatePath: string]: TemplateBuildState;
  };
}

export interface MigrationError {
  file: string;
  error: string;
  templateName: string;
}

export interface CLIConfig {
  filter: string;
  wipIndicator: string;
  wrapInTransaction: boolean;
  banner: string;
  footer: string;
  templateDir: string;
  migrationDir: string;
  buildLog: string;
  localBuildLog: string;
  pgConnection: string;
}

export interface CLIResult {
  errors: MigrationError[];
  applied: string[];
}

export interface TemplateStatus {
  name: string;
  path: string;
  currentHash: string;
  migrationHash: string | null;
  buildState: TemplateBuildState;
}

================
File: supabase/migrations/20241229153624_tmpl-test.sql
================
-- Generated from template: supabase/migrations-templates/test.sql
-- You very likely **DO NOT** want to manually edit this generated file.

BEGIN;
CREATE OR REPLACE FUNCTION public.test()
returns void as $$
BEGIN
  RAISE NOTICE 'Hel11111111s111lo!!';
END;
$$ language plpgsql;

COMMIT;

-- Last built: Never

================
File: supabase/migrations-templates/.buildlog.json
================
{
  "version": "1.0",
  "lastTimestamp": "20241229153624",
  "templates": {
    "supabase/migrations-templates/test.sql": {
      "lastBuildHash": "428c3836145f47cfa0de99a57e4fd3f0",
      "lastBuildDate": "2024-12-29T15:36:24.783Z",
      "lastMigrationFile": "20241229153624_tmpl-test.sql"
    }
  }
}

================
File: supabase/migrations-templates/another.wip.sql
================
-- lol
-- llxx22asdxxss111111sssssssssx123132ssxssas123dasd--s
-- xxxxxxsssssssss --
-- nope

================
File: supabase/migrations-templates/new.wip.sql
================
CREATE OR REPLACE FUNCTION public.just_trying_shit()
returns void as $$
BEGIN
  RAISE NOTICE 'Hello, man!xxx!1';
END;
$$ language plpgsql;

================
File: supabase/migrations-templates/test.sql
================
CREATE OR REPLACE FUNCTION public.test()
returns void as $$
BEGIN
  RAISE NOTICE 'Hel11111111s11!1lo!!';
END;
$$ language plpgsql;

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp
.env

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "srtd"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: './seeds/*.sql'
sql_paths = ['./seed.sql']

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: .editorconfig
================
root = true

[*]
indent_style = space
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.yml]
indent_style = space
indent_size = 2

================
File: .gitattributes
================
* text=auto eol=lf

================
File: .gitignore
================
node_modules
dist
supabase/migrations-templates/.buildlog.local.json

================
File: .npmignore
================
src/
__tests__/
.github/
.vscode/
tsconfig.json
tsup.config.ts
.eslintrc
.prettierrc
vitest.config.ts
.buildlog.json
srtdrc.json

================
File: .prettierignore
================
dist

================
File: .prettierrc.json
================
{
  "singleQuote": true,
  "trailingComma": "es5",
  "tabWidth": 2,
  "semi": true,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "printWidth": 100
}

================
File: Ink UI readme.md
================
[![](https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/banner2-direct.svg)](https://github.com/vshymanskyy/StandWithUkraine/blob/main/docs/README.md)

# Ink UI [![test](https://github.com/vadimdemedes/ink-ui/actions/workflows/test.yml/badge.svg)](https://github.com/vadimdemedes/ink-ui/actions/workflows/test.yml)

> Collection of customizable UI components for CLIs made with [Ink](https://term.ink).

## Install

```sh
npm install @inkjs/ui
```

_This assumes you've already set up [Ink](https://term.ink). The easiest way to get started is [create-ink-app](https://github.com/vadimdemedes/create-ink-app)._

## Components

### Text input

[Documentation](docs/text-input.md)

`TextInput` is used for entering any single-line input with an optional autocomplete.

```jsx
import { TextInput } from '@inkjs/ui';

<TextInput
  placeholder="Enter your name..."
  onSubmit={name => {
    // `name` contains user input
  }}
/>;
```

<img src="media/text-input.gif" width="400">

### Email input

[Documentation](docs/email-input.md)

`EmailInput` is used for entering an email. After "@" character is entered, domain can be autocompleted from the list of most popular email providers.

```jsx
import { EmailInput } from '@inkjs/ui';

<EmailInput
  placeholder="Enter email..."
  onSubmit={email => {
    // `email` contains user input
  }}
/>;
```

<img src="media/email-input.gif" width="400">

### Password input

[Documentation](docs/password-input.md)

`PasswordInput` is used for entering sensitive data, like passwords, API keys and so on. It works the same way as `TextInput`, except input value is masked and replaced with asterisks ("\*").

```jsx
import { PasswordInput } from '@inkjs/ui';

<PasswordInput
  placeholder="Enter password..."
  onSubmit={password => {
    // `password` contains user input
  }}
/>;
```

<img src="media/password-input.gif" width="400">

### Confirm input

[Documentation](docs/confirm-input.md)

`ConfirmInput` shows a common "Y/n" input to confirm or cancel an operation your CLI wants to perform.

```jsx
import { ConfirmInput } from '@inkjs/ui';

<ConfirmInput
  onConfirm={() => {
    // confirmed
  }}
  onCancel={() => {
    // cancelled
  }}
/>;
```

<img src="media/confirm-input.png" width="200">

### Select

[Documentation](docs/select.md)

`Select` shows a scrollable list of options for a user to choose from.

```jsx
import { Select } from '@inkjs/ui';

<Select
  options={[
    {
      label: 'Red',
      value: 'red',
    },
    {
      label: 'Green',
      value: 'green',
    },
    {
      label: 'Yellow',
      value: 'yellow',
    },
    /* ... */
  ]}
  onChange={newValue => {
    // `newValue` equals the `value` field of the selected option
    // For example, "yellow"
  }}
/>;
```

<img src="media/select.gif" width="400">

### Multi select

[Documentation](docs/multi-select.md)

`MultiSelect` is similar to `Select`, except user can choose multiple options.

```jsx
import { MultiSelect } from '@inkjs/ui';

<MultiSelect
  options={[
    {
      label: 'Red',
      value: 'red',
    },
    {
      label: 'Green',
      value: 'green',
    },
    {
      label: 'Yellow',
      value: 'yellow',
    },
    /* ... */
  ]}
  onChange={newValue => {
    // `newValue` is an array of `value` fields of the selected options
    // For example, ["green", "yellow"]
  }}
/>;
```

<img src="media/multi-select.gif" width="400">

### Spinner

[Documentation](docs/spinner.md)

`Spinner` indicates that something is being processed and CLI is waiting for it to complete.

```jsx
import { Spinner } from '@inkjs/ui';

<Spinner label="Loading" />;
```

<img src="media/spinner.gif" width="400">

### Progress bar

[Documentation](docs/progress-bar.md)

`ProgressBar` is an extended version of `Spinner`, where it's possible to calculate a progress percentage.

```jsx
import { ProgressBar } from '@inkjs/ui';

// `progress` must be a number between 0 and 100
<ProgressBar value={progress} />;
```

<img src="media/progress-bar.gif" width="400">

### Badge

[Documentation](docs/badge.md)

`Badge` can be used to indicate a status of a certain item, usually positioned nearby the element it's related to.

```jsx
import {Badge} from '@inkjs/ui';

<Badge color="green">Pass</Badge>
<Badge color="red">Fail</Badge>
<Badge color="yellow">Warn</Badge>
<Badge color="blue">Todo</Badge>
```

<img src="media/badge.png" width="400">

### Status message

[Documentation](docs/status-message.md)

`StatusMessage` can also be used to indicate a status, but when longer explanation of such status is required.

```jsx
import {StatusMessage} from '@inkjs/ui';

<StatusMessage variant="success">
	New version is deployed to production
</StatusMessage>

<StatusMessage variant="error">
  Failed to deploy a new version of this app
</StatusMessage>

<StatusMessage variant="warning">
    Health checks aren't configured
</StatusMessage>

<StatusMessage variant="info">
    This version is already deployed
</StatusMessage>
```

<img src="media/status-message.png" width="400">

### Alert

[Documentation](docs/alert.md)

`Alert` is used to focus user's attention to important messages.

```jsx
import {Alert} from '@inkjs/ui';

<Alert variant="success">
    A new version of this CLI is available
</Alert>

<Alert variant="error">
    Your license is expired
</Alert>

<Alert variant="warning">
    Current version of this CLI has been deprecated
</Alert>

<Alert variant="info">
    API won't be available tomorrow night
</Alert>
```

<img src="media/alert.png" width="600">

### Unordered list

[Documentation](docs/unordered-list.md)

`UnorderedList` is used to show lists of items.

```jsx
import { UnorderedList } from '@inkjs/ui';

<UnorderedList>
  <UnorderedList.Item>
    <Text>Red</Text>
  </UnorderedList.Item>

  <UnorderedList.Item>
    <Text>Green</Text>

    <UnorderedList>
      <UnorderedList.Item>
        <Text>Light</Text>
      </UnorderedList.Item>

      <UnorderedList.Item>
        <Text>Dark</Text>
      </UnorderedList.Item>
    </UnorderedList>
  </UnorderedList.Item>

  <UnorderedList.Item>
    <Text>Blue</Text>
  </UnorderedList.Item>
</UnorderedList>;
```

<img src="media/unordered-list.png" width="400">

### Ordered list

[Documentation](docs/ordered-list.md)

`OrderedList` is used to show lists of numbered items.

```jsx
import { OrderedList } from '@inkjs/ui';

<OrderedList>
  <OrderedList.Item>
    <Text>Red</Text>
  </OrderedList.Item>

  <OrderedList.Item>
    <Text>Green</Text>

    <OrderedList>
      <OrderedList.Item>
        <Text>Light</Text>
      </OrderedList.Item>

      <OrderedList.Item>
        <Text>Dark</Text>
      </OrderedList.Item>
    </OrderedList>
  </OrderedList.Item>

  <OrderedList.Item>
    <Text>Blue</Text>
  </OrderedList.Item>
</OrderedList>;
```

<img src="media/ordered-list.png" width="400">

## Theming

All component have their styles defined in a theme, which is accessible to components via React context. Ink UI ships with a default theme and it can be customized or replaced with a different theme altogether.

Let's get a quick look on how to customize a `Spinner`'s component theme. Here's how it looks by default:

<img src="media/spinner.gif" width="400">

First, look up component's default theme, which will give an overview which parts does this component consist of. Documentation of each component includes a link to component's `theme.ts` file on top. In the case of `Spinner`, it's [source/components/spinner/theme.ts](source/components/spinner/theme.ts).

Here's the part we care about:

```tsx
const theme = {
  styles: {
    container: (): BoxProps => ({
      gap: 1,
    }),
    frame: (): TextProps => ({
      color: 'blue',
    }),
    label: (): TextProps => ({}),
  },
} satisfies ComponentTheme;

export default theme;
```

This component theme hints that `Spinner` has 3 parts: container, frame and a label. So to customize the color of the spinner itself, we'd want to change the `color` prop returned from the `frame` function.

To customize the default theme, use `extendTheme` function and make that custom theme available to children components via `ThemeProvider`.

```tsx
import { render, type TextProps } from 'ink';
import { Spinner, ThemeProvider, extendTheme, defaultTheme } from '@inkjs/ui';

const customTheme = extendTheme(defaultTheme, {
  components: {
    Spinner: {
      styles: {
        frame: (): TextProps => ({
          color: 'magenta',
        }),
      },
    },
  },
});

function Example() {
  return (
    <ThemeProvider theme={customTheme}>
      <Spinner label="Loading" />
    </ThemeProvider>
  );
}

render(<Example />);
```

With custom theme applied, `Spinner` now renders a magenta spinner, instead of the default blue one.

<img src="media/spinner-theme.gif" width="400">

There are also cases where styles change based on some condition. For example, [`StatusMessage`](docs/status-message.md) changes the color of an icon based on the `variant` prop.

Here's a sample code from its [theme](source/components/status-message/theme.ts).

```ts
const colorByVariant = {
  success: 'green',
  error: 'red',
  warning: 'yellow',
  info: 'blue',
};

const theme = {
  styles: {
    icon: ({ variant }) => ({
      color: colorByVariant[variant],
    }),
  },
};
```

Since each field in `styles` object is a function, it can return different styles based on the props that were passed in or a state of a component.

Component themes can also include configuration for rendering a component in a `config` object, that's not related to styling. For example, [`UnorderedList`](docs/unordered-list.md) specifies a `marker`, which is a character that's rendered before each list item.

Here's a sample code from its [theme](source/components/unordered-list/theme.ts).

```ts
const theme = {
  config: () => ({
    marker: '‚îÄ',
  }),
};
```

<img src="media/unordered-list.png" width="400">

Changing `marker` to `'+'` would render this:

<img src="media/unordered-list-theme.png" width="400">

Components shipped in Ink UI automatically read the necessary styles and configuration from a theme. However, if you're adding a new custom component and a theme for it, use `useComponentTheme` hook to access it.

```tsx
import React, { render, Text, type TextProps } from 'ink';
import {
  ThemeProvider,
  defaultTheme,
  extendTheme,
  useComponentTheme,
  type ComponentTheme,
} from '@inkjs/ui';

const customLabelTheme = {
  styles: {
    label: (): TextProps => ({
      color: 'green',
    }),
  },
} satisfies ComponentTheme;

type CustomLabelTheme = typeof customLabelTheme;

const customTheme = extendTheme(defaultTheme, {
  components: {
    CustomLabel: customLabelTheme,
  },
});

function CustomLabel() {
  const { styles } = useComponentTheme<CustomLabelTheme>('CustomLabel');

  return <Text {...styles.label()}>Hello world</Text>;
}

function Example() {
  return (
    <ThemeProvider theme={customTheme}>
      <CustomLabel />
    </ThemeProvider>
  );
}

render(<Example />);
```

================
File: package.json
================
{
  "name": "srtd",
  "version": "0.1.0",
  "license": "MIT",
  "description": "Supabase Repeatable Template Definitions (srtd) is a powerful CLI for managing repeatable SQL templates tailored for Postgres features that require full redefinition, such as functions, stored procedures, and RLS policies. Streamline your development with live reloads and simplified workflows.",
  "bin": "dist/cli.js",
  "type": "module",
  "engines": {
    "node": ">=20"
  },
  "author": {
    "name": "Timm Stokke",
    "email": "timm@stokke.me",
    "url": "https://timm.stokke.me"
  },
  "keywords": [
    "cli",
    "migrations",
    "database",
    "postgresql",
    "supabase",
    "sql-templates",
    "repeatable-migrations",
    "database-migrations",
    "supabase-cli"
  ],
  "scripts": {
    "start": "tsx src/cli.tsx",
    "build": "rm -rf dist && tsc",
    "typecheck": "tsc --noEmit",
    "dev": "tsc --watch",
    "prettier": "prettier --write .",
    "test": "vitest",
    "x": "npm run build && npm link && chmod u+x ./dist/cli.js && srtd",
    "repomix": "npx repomix ./src vitest.config.ts package.json ./__tests__"
  },
  "files": [
    "dist"
  ],
  "dependencies": {
    "@inkjs/ui": "^2.0.0",
    "chokidar": "^4.0.3",
    "glob": "^7.2.3",
    "ink": "^5.0.0",
    "pastel": "^3.0.0",
    "pg": "^8.13.1",
    "react": "^18.0.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@sindresorhus/tsconfig": "^7.0.0",
    "@types/glob": "^8.1.0",
    "@types/node": "^22.10.2",
    "@types/pg": "^8.11.10",
    "@types/react": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "chalk": "^5.3.0",
    "eslint": "^8.0.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.1.0",
    "ink-testing-library": "^4.0.0",
    "prettier": "^3.4.2",
    "tsx": "^4.19.2",
    "typescript": "^5.7.2",
    "vitest": "^1.0.0"
  },
  "eslintConfig": {
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:react/recommended",
      "plugin:react-hooks/recommended",
      "prettier"
    ],
    "parser": "@typescript-eslint/parser",
    "rules": {
      "react/prop-types": "off"
    }
  }
}

================
File: Pastel-readme.md
================
> Next.js-like framework for CLIs made with [Ink](https://github.com/vadimdemedes/ink).

## Features

- Create files in `commands` folder to add commands.
- Create folders in `commands` to add subcommands.
- Define options and arguments via [Zod](https://zod.dev).
- Full type-safety of options and arguments thanks to Zod.
- Auto-generated help message for commands, options and arguments.
- Uses battle-tested [Commander](https://github.com/tj/commander.js) package under the hood.

## Install

```console
npm install pastel ink react zod
```

## Getting started

Use [create-pastel-app](https://github.com/vadimdemedes/create-pastel-app) to quickly scaffold a Pastel app with TypeScript, linter and tests set up.

```console
npm create pastel-app hello-world
hello-world
```

<details><summary>Manual setup</summary>
<p>

1. Set up a new project.

```console
mkdir hello-world
cd hello-world
npm init --yes
```

2. Install Pastel and TypeScript.

```console
npm install pastel
npm install --save-dev typescript @sindresorhus/tsconfig
```

3. Create a `tsconfig.json` file to set up TypeScript.

```json
{
  "extends": "@sindresorhus/tsconfig",
  "compilerOptions": {
    "moduleResolution": "node16",
    "module": "node16",
    "outDir": "build",
    "sourceMap": true,
    "tsx": "react"
  },
  "include": ["source"]
}
```

4. Create a `source` folder for the source code.

```console
mkdir source
```

5. Create a `source/cli.ts` file with the following code, which will be CLI's entrypoint:

```js
#!/usr/bin/env node
import Pastel from 'pastel';

const app = new Pastel({
  importMeta: import.meta,
});

await app.run();
```

6. Create `source/commands` folder for defining CLI's commands.

```console
mkdir source/commands
```

7. Create an `source/commands/index.tsx` file for a default command, with the following code:

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  name: zod.string().describe('Your name'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Index({ options }: Props) {
  return <Text>Hello, {options.name}!</Text>;
}
```

8. Build your CLI.

```console
npx tsc
```

9. Set up an executable file.

9.1. Add `bin` field to `package.json`, which points to the compiled version of `source/cli.ts` file.

```diff
	"bin": "build/cli.js"
```

9.2. Make your CLI available globally.

```console
npm link --global
```

10. Run your CLI.

```console
hello-world --name=Jane
```

```
Hello, Jane!
```

```console
hello-world --help
```

```
Usage: hello-world [options]

Options:
  --name         Your name
  -v, --version  Show version number
  -h, --help     Show help

```

</p></details>

## Table of contents

- [Commands](#commands)
  - [Index commands](#index-commands)
  - [Default commands](#default-commands)
  - [Subcommands](#subcommands)
  - [Aliases](#aliases)
- [Options](#options)
  - [Types](#types)
    - [String](#string)
    - [Number](#number)
    - [Boolean](#boolean)
    - [Enum](#enum)
    - [Array](#array)
    - [Set](#set)
  - [Optional or required options](#optional-or-required-options)
  - [Default value](#default-value)
  - [Alias](#alias)
- [Arguments](#arguments)
  - [Types](#types-1)
    - [String](#string-1)
    - [Number](#number-1)
    - [Enum](#enum-1)
- [Custom app](#custom-app)
- [Custom program name](#custom-program-name)
- [Custom description](#custom-description)
- [Custom version](#custom-version)
- [API](#api)

## Commands

Pastel treats every file in the `commands` folder as a command, where filename is a command's name (excluding the extension). Files are expected to export a React component, which will be rendered when command is executed.

You can also nest files in folders to create subcommands.

Here's an example, which defines `login` and `logout` commands:

```
commands/
	login.tsx
	logout.tsx
```

**login.tsx**

```tsx
import React from 'react';
import { Text } from 'ink';

export default function Login() {
  return <Text>Logging in</Text>;
}
```

**logout.tsx**

```tsx
import React from 'react';
import { Text } from 'ink';

export default function Logout() {
  return <Text>Logging out</Text>;
}
```

Given that your executable is named `my-cli`, you can execute these commands like so:

```
$ my-cli login
$ my-cli logout
```

### Index commands

Files named `index.tsx` are index commands. They will be executed by default, when no other command isn't specified.

```
commands/
	index.tsx
	login.tsx
	logout.tsx
```

Running `my-cli` without a command name will execute `index.tsx` command.

```
$ my-cli
```

Index command is useful when you're building a single-purpose CLI, which has only one command. For example, [`np`](https://github.com/sindresorhus/np) or [fast-cli](https://github.com/sindresorhus/fast-cli).

### Default commands

Default commands are similar to index commands, because they too will be executed when an explicit command isn't specified. The difference is default commands still have a name, just like any other command, and they'll show up in the help message.

Default commands are useful for creating shortcuts to commands that are used most often.

Let's say there are 3 commands available: `deploy`, `login` and `logout`.

```
commands/
	deploy.tsx
	login.tsx
	logout.tsx
```

Each of them can be executed by typing their name.

```
$ my-cli deploy
$ my-cli login
$ my-cli logout
```

Chances are, `deploy` command is going to be used a lot more frequently than `login` and `logout`, so it makes sense to make `deploy` a default command in this CLI.

Export a variable named `isDefault` from the command file and set it to `true` to mark that command as a default one.

```diff
import React from 'react';
import {Text} from 'ink';

+ export const isDefault = true;

export default function Deploy() {
	return <Text>Deploying...</Text>;
}
```

Now, running `my-cli` or `my-cli deploy` will execute a `deploy` command.

```
$ my-cli
```

[Vercel's CLI](https://github.com/vercel/vercel/tree/main/packages/cli) is a real-world example of this approach, where both `vercel` and `vercel deploy` trigger a new deploy of your project.

### Subcommands

As your CLI grows and more commands are added, it makes sense to group the related commands together.

To do that, create nested folders in `commands` folder and put the relevant commands inside to create subcommands. Here's an example for a CLI that triggers deploys and manages domains for your project:

```
commands/
	deploy.tsx
	login.tsx
	logout.tsx
	domains/
		list.tsx
		add.tsx
		remove.tsx
```

Commands for managing domains would be executed like so:

```
$ my-cli domains list
$ my-cli domains add
$ my-cli domains remove
```

Subcommands can even be deeply nested within many folders.

### Aliases

Commands can have an alias, which is usually a shorter alternative name for the same command. Power users prefer aliases instead of full names for commands they use often. For example, most users type `npm i` instead of `npm install`.

Any command in Pastel can assign an alias by exporting a variable named `alias`:

```diff
import React from 'react';
import {Text} from 'ink';

+ export const alias = 'i';

export default function Install() {
	return <Text>Installing something...</Text>;
}
```

Now the same `install` command can be executed by only typing `i`:

```
$ my-cli i
```

## Options

Commands can define options to customize their default behavior or ask for some additional data to run properly.
For example, a command that creates a new server might specify options for choosing a server's name, an operating system, memory size or a region where that server should be spin up.

Pastel uses [Zod](https://zod.dev) to define, parse and validate command options. Export a variable named `options` and set a Zod [object schema](https://zod.dev/?id=objects). Pastel will parse that schema and automatically set these options up. When command is executed, option values are passed via `options` prop to your component.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  name: zod.string().describe('Server name'),
  os: zod.enum(['Ubuntu', 'Debian']).describe('Operating system'),
  memory: zod.number().describe('Memory size'),
  region: zod.enum(['waw', 'lhr', 'nyc']).describe('Region'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Deploy({ options }: Props) {
  return (
    <Text>
      Deploying a server named "{options.name}" running {options.os} with memory size of{' '}
      {options.memory} MB in {options.region} region
    </Text>
  );
}
```

With options set up, here's an example `deploy` command:

```
$ my-cli deploy --name=Test --os=Ubuntu --memory=1024 --region=waw
Deploying a server named "Test" running Ubuntu with memory size of 1024 MB in waw region.
```

Help message is auto-generated for you as well.

```
$ my-cli deploy --help
Usage: my-cli deploy [options]

Options:
  --name         Server name
  --os           Operating system (choices: "Ubuntu", "Debian")
  --memory       Memory size
  --region       Region
  -v, --version  Show version number
  -h, --help     Show help
```

### Types

Pastel only supports [string](https://zod.dev/?id=strings), [number](https://zod.dev/?id=numbers), [boolean](https://zod.dev/?id=booleans), [enum](https://zod.dev/?id=zod-enums), [array](https://zod.dev/?id=arrays) and [set](https://zod.dev/?id=sets) types for defining options.

#### String

Example that defines a `--name` string option:

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  name: zod.string().describe('Your name'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Name = {options.name}</Text>;
}
```

```
$ my-cli --name=Jane
Name = Jane
```

#### Number

Example that defines a `--size` number option:

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  age: zod.number().describe('Your age'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Age = {options.age}</Text>;
}
```

```
$ my-cli --age=28
Age = 28
```

#### Boolean

Example that defines a `--compress` number option:

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  compress: zod.boolean().describe('Compress output'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Compress = {String(options.compress)}</Text>;
}
```

```
$ my-cli --compress
Compress = true
```

Boolean options are special, because they can't be required and default to `false`, even if Zod schema doesn't use a `default(false)` function.

When boolean option defaults to `true`, it's treated as a negated option, which adds a `no-` prefix to its name.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  compress: zod.boolean().default(true).describe("Don't compress output"),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Compress = {String(options.compress)}</Text>;
}
```

```
$ my-cli --no-compress
Compress = false
```

#### Enum

Example that defines an `--os` enum option with a set of allowed values.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  os: zod.enum(['Ubuntu', 'Debian']).describe('Operating system'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Operating system = {options.os}</Text>;
}
```

```
$ my-cli --os=Ubuntu
Operating system = Ubuntu

$ my-cli --os=Debian
Operating system = Debian

$ my-cli --os=Windows
error: option '--os <os>' argument 'Windows' is invalid. Allowed choices are Ubuntu, Debian.
```

#### Array

Example that defines a `--tag` array option, which can be specified multiple times.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  tag: zod.array(zod.string()).describe('Tags'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Tags = {options.tags.join(', ')}</Text>;
}
```

```
$ my-cli --tag=App --tag=Production
Tags = App, Production
```

Array options can only include strings (`zod.string`), numbers (`zod.number`) or enums (`zod.enum`).

#### Set

Example that defines a `--tag` set option, which can be specified multiple times. It's similar to an array option, except duplicate values are removed, since the option's value is a [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  tag: zod.set(zod.string()).describe('Tags'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Tags = {[...options.tags].join(', ')}</Text>;
}
```

```
$ my-cli --tag=App --tag=Production --tag=Production
Tags = App, Production
```

Set options can only include strings (`zod.string`), numbers (`zod.number`) or enums (`zod.enum`).

### Optional or required options

Pastel determines whether option is optional or required by parsing its Zod schema. Since Zod schemas are required by default, so are options in Pastel.

If an option isn't be required for a command to function properly, mark it as optional.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  os: zod.enum(['Ubuntu', 'Debian']).optional().describe('Operating system'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Operating system = {options.os ?? 'unspecified'}</Text>;
}
```

```
$ my-cli --os=Ubuntu
Operating system = Ubuntu

$ my-cli
Operating system = unspecified
```

### Default value

Default value for an option can be set via a `default` function in Zod schema.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const options = zod.object({
  size: zod.number().default(1024).describe('Memory size'),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Memory = {options.size} MB</Text>;
}
```

```
$ my-cli
Memory size = 1024 MB
```

JSON representation of default value will be displayed in the help message.

```
$ my-cli --help
Usage: my-cli [options]

Options:
  --size  Memory size (default: 1024)
```

You can also customize it via `defaultValueDescription` option in `option` helper function.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { option } from 'pastel';

export const options = zod.object({
  size: zod
    .number()
    .default(1024)
    .describe(
      option({
        description: 'Memory size',
        defaultValueDescription: '1 GB',
      })
    ),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Memory = {options.size} MB</Text>;
}
```

```
$ my-cli --help
Usage: my-cli [options]

Options:
  --size  Memory size (default: 1 GB)
```

### Alias

Options can specify an alias, which is usually the first letter of an original option name.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { option } from 'pastel';

export const options = zod.object({
  force: zod.boolean().describe(
    option({
      description: 'Force',
      alias: 'f',
    })
  ),
});

type Props = {
  options: zod.infer<typeof options>;
};

export default function Example({ options }: Props) {
  return <Text>Force = {String(options.force)}</Text>;
}
```

```
$ my-cli --force
Force = true

$ my-cli -f
Force = true
```

## Arguments

Arguments are similar to options, except they don't require a flag to specify them (e.g. `--name`) and they're always specified after command name and options. For example, [`mv`](https://linux.die.net/man/1/mv) requires 2 arguments, where first argument is a source path and second argument is a target path.

```
$ mv source.txt target.txt
```

A theoretical `mv` command in Pastel can define similar arguments like so:

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const args = zod.tuple([zod.string(), zod.string()]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Move({ args }: Props) {
  return (
    <Text>
      Moving from {args[0]} to {args[1]}
    </Text>
  );
}
```

```
$ my-cli source.txt target.txt
Moving from source.txt to target.txt
```

This command defines two positional arguments, which means that argument's position matters for command's execution. This is why positional arguments are defined via [zod.tuple](https://zod.dev/?id=tuples) in Zod, where a specific number of values is expected.

However, there are commands like [`rm`](https://linux.die.net/man/1/rm), which can accept any number of arguments. To accomplish that in Pastel, use [`zod.array`](https://zod.dev/?id=arrays) instead.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';

export const args = zod.array(zod.string());

type Props = {
  args: zod.infer<typeof args>;
};

export default function Remove({ args }: Props) {
  return <Text>Removing {args.join(', ')}</Text>;
}
```

```
$ my-cli a.txt b.txt c.txt
Removing a.txt, b.txt, c.txt
```

### Types

Pastel only supports [string](https://zod.dev/?id=strings), [number](https://zod.dev/?id=numbers) and [enum](https://zod.dev/?id=zod-enums) types for defining arguments inside [tuple](https://zod.dev/?id=tuples) or [array](https://zod.dev/?id=arrays).

#### String

Example that defines a string argument.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { argument } from 'pastel';

export const args = zod.tuple([
  zod.string().describe(
    argument({
      name: 'name',
      description: 'Your name',
    })
  ),
]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Hello({ args }: Props) {
  return <Text>Hello, {args[0]}</Text>;
}
```

```
$ my-cli Jane
Hello, Jane
```

#### Number

Example that defines a number argument.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { argument } from 'pastel';

export const args = zod.tuple([
  zod.number().describe(
    argument({
      name: 'age',
      description: 'Age',
    })
  ),
]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Hello({ args }: Props) {
  return <Text>Your age is {args[0]}</Text>;
}
```

```
$ my-cli 28
Your age is 28
```

#### Enum

Example that defines an enum argument.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { argument } from 'pastel';

export const args = zod.tuple([
  zod.enum(['Ubuntu', 'Debian']).describe(
    argument({
      name: 'os',
      description: 'Operating system',
    })
  ),
]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Example({ args }: Props) {
  return <Text>Operating system = {args[0]}</Text>;
}
```

```
$ my-cli Ubuntu
Operating system = Ubuntu
```

### Default value

Default value for an argument can be via a `default` function in Zod schema.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { argument } from 'pastel';

export const args = zod.tuple([
  zod
    .number()
    .default(1024)
    .describe(
      argument({
        name: 'number',
        description: 'Some number',
      })
    ),
]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Example({ args }: Props) {
  return <Text>Some number = {args[0]}</Text>;
}
```

```
$ my-cli
Some number = 1024
```

JSON representation of default value will be displayed in the help message.

```
$ my-cli --help
Usage: my-cli [options] [number]

Arguments:
  number  Some number (default: 1024)
```

You can also customize it via `defaultValueDescription` option in `option` helper function.

```tsx
import React from 'react';
import { Text } from 'ink';
import zod from 'zod';
import { argument } from 'pastel';

export const args = zod.tuple([
  zod
    .number()
    .default(1024)
    .describe(
      argument({
        name: 'number',
        description: 'Some number',
        defaultValueDescription: '1,204',
      })
    ),
]);

type Props = {
  args: zod.infer<typeof args>;
};

export default function Example({ args }: Props) {
  return <Text>Some number = {args[0]}</Text>;
}
```

```
$ my-cli --help
Usage: my-cli [options] [number]

Arguments:
  number  Some number (default: 1,024)
```

## Custom app

Similar to Next.js, Pastel wraps every command component with a component exported from `commands/_app.tsx`. If this file doesn't exist, Pastel uses a default app component, which does nothing but render your component with `options` and `args` props.

```tsx
import React from 'react';
import type { AppProps } from 'pastel';

export default function App({ Component, commandProps }: AppProps) {
  return <Component {...commandProps} />;
}
```

You can copy paste that code into `commands/_app.tsx` and add some logic that will be shared across all commands.

## Custom program name

Pastel extracts a program name from the `name` field in the nearest `package.json` file. If it doesn't exist, a first argument in `process.argv` is used.

When the name of an executable doesn't match the `name` in `package.json`, it can be customized via a `name` option during app initialization.

```tsx
import Pastel from 'pastel';

const app = new Pastel({
  name: 'custom-cli-name',
});

await app.run();
```

## Custom description

Similar to program name, Pastel looks for a description in `description` field in the nearest `package.json` file. To customize it, use a `description` option when initializating Pastel.

```tsx
import Pastel from 'pastel';

const app = new Pastel({
  description: 'Custom description',
});

await app.run();
```

## Custom version

Similar to program name and description, Pastel looks for a version in `version` field in the nearest `package.json` file. If Pastel can't find it, version will be hidden in the help message and `-v, --version` options won't be available.

To customize it, use a `version` option during app initialization.

```tsx
import Pastel from 'pastel';

const app = new Pastel({
	version: '1.0.0
});

await app.run()
```

## API

### Pastel(options)

Initializes a Pastel app.

#### options

Type: `object`

##### name

Type: `string`

Program name. Defaults to `name` in the nearest package.json or the name of the executable.

##### version

Type: `string`

Version. Defaults to `version` in the nearest package.json.

##### description

Type: `string`

Description. Defaults to `description` in the nearest package.json.

##### importMeta

Type: [`ImportMeta`](https://nodejs.org/dist/latest/docs/api/esm.html#esm_import_meta)

Pass in [`import.meta`](https://nodejs.org/dist/latest/docs/api/esm.html#esm_import_meta). This is used to find the `commands` directory.

#### run(argv)

Parses the arguments and runs the app.

##### argv

Type: `Array`\
Default: `process.argv`

Program arguments.

### option(config)

Set additional metadata for an option. Must be used as an argument to `describe` function from Zod.

#### config

Type: `object`

##### description

Type: `string`

Description. If description is missing, option won't appear in the "Options" section of the help message.

##### defaultValueDescription

Type: `string`

Description of a default value.

##### valueDescription

Type: `string`

Description of a value. Replaces "value" in `--flag <value>` in the help message.

##### alias

Type: `string`

Alias. Usually a first letter of the full option name.

### argument(config)

Set additional metadata for an argument. Must be used as an argument to `describe` function from Zod.

#### config

Type: `object`

##### name

Type: `string`\
Default: `'arg'`

Argument's name. Displayed in "Usage" part of the help message. Doesn't affect how argument is parsed.

##### description

Type: `string`

Description of an argument. If description is missing, argument won't appear in the "Arguments" section of the help message.

##### defaultValueDescription

Type: `string`

Description of a default value.

================
File: README.md
================
# srtd - Supabase Repeatable Template Definitions

`srtd` streamlines development and maintenance of Postgres functions, stored procedures, and RLS policies in [Supabase](https://supabase.com) projects through a template-based workflow.

## Why This Tool Exists

After years in frontend development, returning to SQL with Supabase highlighted two pain points:

1. Code reviews were challenging since function changes appear as complete rewrites rather than diffs
2. Local development required tedious manual steps to test database changes

Finding no simple solution (besides complex DSLs or expensive tools), we built `srtd` to solve these specific problems. While primarily designed to scratch our own itch, it should work with any Postgres setup using SQL files for migrations.

> [!NOTE]
> This is a focused tool that does one thing well - making Postgres development smoother in Supabase. It's not expanding beyond Postgres, but PR's for improvements are welcome!

## Key Benefits

- **Real-time Development**: Changes to templates automatically update your local database
- **Clear Code Reviews**: See actual changes instead of entire function redefinitions
- **Version Control Friendly**: Track meaningful template changes in Git history
- **Supabase Compatible**: Works alongside existing migration workflows

## Installation

```bash
npm install -g srtd  # Global installation
# or
npm install --save-dev srtd  # Project-level installation
```

## Quick Start

1. **Set up your project**:

   ```bash
   srtd init
   ```

2. **Create a template** (e.g., `supabase/migrations-templates/my_function.sql`):

   ```sql
   DROP FUNCTION IF EXISTS my_function();
   CREATE OR REPLACE FUNCTION my_function()
   RETURNS void AS $$
   BEGIN
     -- Your function logic here
   END;
   $$ LANGUAGE plpgsql;
   ```

3. **Start development mode**:

   ```bash
   srtd watch  # Changes auto-apply to local database
   ```

4. **Generate migration when ready**:
   ```bash
   srtd build  # Creates timestamped migration file
   supabase migrate up  # Apply using Supabase CLI
   ```

## Commands

- `srtd init` - Create project structure and config
- `srtd watch` - Auto-apply template changes to local database
- `srtd build` - Generate Supabase migration files
- `srtd apply` - Build and apply templates directly
- `srtd register` - Register existing templates
- `srtd status` - View template status

## Best For

‚úÖ Database objects requiring full redefinition:

- Functions and stored procedures
- RLS (Row-Level Security) policies
- Custom roles and permissions

‚ùå Not recommended for:

- Table definitions
- Indexes
- Incremental changes

## Configuration

`.srtdrc.json` is created during initialization:

```json
{
  "wipIndicator": ".wip",
  "filter": "**/*.sql",
  "banner": "You very likely **DO NOT** want to manually edit this generated file.",
  "footer": "",
  "wrapInTransaction": true,
  "templateDir": "supabase/migrations-templates",
  "migrationDir": "supabase/migrations",
  "buildLog": "supabase/migrations-templates/.buildlog.json",
  "localBuildLog": "supabase/migrations-templates/.buildlog.local.json",
  "pgConnection": "postgresql://postgres:postgres@localhost:54322/postgres"
}
```

## Advanced Features

### Template Status Tracking

`srtd` maintains two logs:

- `.buildlog.json` - Tracks build status (commit to Git)
- `.buildlog.local.json` - Tracks local changes (gitignored)

### Work in Progress

Add `.wip.sql` extension to templates under development:

```bash
my_function.wip.sql  # Won't generate migrations during build
```

### Register Existing Objects

Import existing database objects into the template system:

```bash
srtd register my_function.sql
```

## Best Practices

1. Write idempotent templates (safe to run multiple times)
2. One logical unit per template
3. Use `.wip.sql` for experimental changes
4. Never edit generated migrations directly
5. Commit templates and migrations together

## License

MIT License - See [LICENSE](LICENSE) for details.

================
File: tsconfig.json
================
{
  "extends": "@sindresorhus/tsconfig",
  "compilerOptions": {
    "moduleResolution": "node16",
    "module": "NodeNext",
    "target": "ES2022",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "declaration": true,
    "sourceMap": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src", "__tests__"],
  "exclude": ["node_modules", "dist"]
}

================
File: vitest.config.ts
================
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'coverage/**',
        'dist/**',
        '**/node_modules/**',
        '**/*.d.ts',
        '**/*.test.{ts,tsx}',
        '**/vitest.config.*',
      ],
    },
    setupFiles: ['./vitest.setup.ts'],
    testTimeout: 10000,
  },
});

================
File: vitest.setup.ts
================
import { afterAll, beforeAll, vi } from 'vitest';
import { tmpdir } from 'os';
import { join } from 'path';
import fs from 'fs/promises';
import { disconnect } from './src/utils/db.connection.js';

export const TEST_ROOT = join(tmpdir(), `srtd-test-${Date.now()}`);

beforeAll(async () => {
  await fs.mkdir(TEST_ROOT, { recursive: true });
});

afterAll(async () => {
  await fs.rm(TEST_ROOT, { recursive: true, force: true });
  await disconnect();
});

vi.mock('./src/utils/config', async () => ({
  getConfig: vi.fn().mockResolvedValue({
    wipIndicator: '.wip',
    filter: '**/*.sql',
    templateDir: 'test-templates',
    migrationDir: 'test-migrations',
    buildLog: '.buildlog-test.json',
    localBuildLog: '.buildlog-test.local.json',
    pgConnection:
      process.env.POSTGRES_URL || 'postgresql://postgres:postgres@localhost:54322/postgres',
    banner: 'Test banner',
    footer: 'Test footer',
    wrapInTransaction: true,
  }),
}));
