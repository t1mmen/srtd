This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T09:58:25.089Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
commands/
  _app.tsx
  apply.tsx
  build.tsx
  index.tsx
  init.tsx
  register.tsx
  status.tsx
  watch.tsx
components/
  StatusIndicator.tsx
  TemplateList.tsx
db-diff-checks/
  .gitignore
  compare_db_state.sh
  test_db_compare.sh
hooks/
  useTemplateState.ts
lib/
  buildTemplates.ts
utils/
  applyMigration.ts
  applyPendingTemplates.ts
  calculateMD5.ts
  config.ts
  createEmptyBuildLog.ts
  db.connection.ts
  displayErrorSummary.ts
  ensureDirectories.ts
  fileExists.ts
  getMigrationFileHash.ts
  getNextTimestamp.ts
  getTimeAgo.ts
  isWipTemplate.ts
  loadBuildLog.ts
  loadTemplates.ts
  registerTemplate.ts
  safeCreate.ts
  saveBuildLog.ts
  templateState.ts
cli.tsx
constants.ts
types.ts

================================================================
Repository Files
================================================================

================
File: commands/_app.tsx
================
import React from 'react';
import type { AppProps } from 'pastel';
import { Box } from 'ink';

export default function App({ Component, commandProps }: AppProps) {
  return (
    <Box flexDirection="column">
      <Component {...commandProps} />
    </Box>
  );
}

================
File: commands/apply.tsx
================
import React from 'react';
import { buildTemplates } from '../lib/buildTemplates.js';

export default function Apply() {
  React.useEffect(() => {
    async function doApply() {
      await buildTemplates({
        skipFiles: true,
        apply: true,
      });
      process.exit(0);
    }
    doApply();
  }, []);
  return null;
}

================
File: commands/build.tsx
================
import React from 'react';
import { buildTemplates } from '../lib/buildTemplates.js';

export default function Build() {
  React.useEffect(() => {
    async function doBuild() {
      await buildTemplates({});
    }
    doBuild();
  }, []);

  return null;
}

================
File: commands/index.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { Select } from '@inkjs/ui';

// Import the "Register" component for demonstration of navigation:
import Register from './register.js';
import Apply from './apply.js';
import Build from './build.js';
import Status from './status.js';
import Watch from './watch.js';

export default function UI() {
  const [selectedCommand, setSelectedCommand] = React.useState<string | null>(null);

  // For now, we only demonstrate navigation to "register"
  if (selectedCommand === 'register') {
    return <Register />;
  }

  if (selectedCommand === 'apply') {
    return <Apply />;
  }

  if (selectedCommand === 'build') {
    return <Build />;
  }

  if (selectedCommand === 'status') {
    return <Status />;
  }

  if (selectedCommand === 'watch') {
    return <Watch />;
  }

  const menuItems = [
    { label: 'üèóÔ∏è  build - Build Supabase migrations from templates', value: 'build' },
    { label: '‚ñ∂Ô∏è  apply - Apply migration templates directly to database', value: 'apply' },
    { label: '‚úçÔ∏è  register - Register templates as already built', value: 'register' },
    {
      label: 'üëÄ  watch - Watch templates for changes and apply directly to database',
      value: 'watch',
    },
    { label: '‚ÑπÔ∏è  status - Show migration status', value: 'status' },
  ];

  return (
    <Box flexDirection="column">
      <Text bold>srtd - Repeatable Template SQL Migration Tool</Text>
      <Text>Select a command:</Text>
      <Box marginTop={1}>
        <Select options={menuItems} onChange={value => setSelectedCommand(value)} />
      </Box>
    </Box>
  );
}

================
File: commands/init.tsx
================
import React from 'react';
import fs from 'fs/promises';
import path from 'path';
import { saveConfig, getConfig } from '../utils/config.js';
import { CONFIG_FILE } from '../constants.js';
import { createEmptyBuildLog } from '../utils/createEmptyBuildLog.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';
import { fileExists } from '../utils/fileExists.js';

export default function Init() {
  React.useEffect(() => {
    async function doInit() {
      try {
        const config = await getConfig();
        const baseDir = process.cwd();
        const configPath = path.join(baseDir, CONFIG_FILE);

        // Check/create config
        if (await fileExists(configPath)) {
          console.log(`‚è≠Ô∏è ${CONFIG_FILE} already exists`);
        } else {
          await saveConfig(baseDir, {});
          console.log(`‚úÖ Created ${CONFIG_FILE} with default configuration`);
        }

        // Create directories
        const dirs = await ensureDirectories(baseDir);
        if (dirs.templateDir) {
          console.log('‚úÖ Created template directory');
        } else {
          console.log('‚è≠Ô∏è Template directory already exists');
        }
        if (dirs.migrationDir) {
          console.log('‚úÖ Created migration directory');
        } else {
          console.log('‚è≠Ô∏è Migration directory already exists');
        }

        // Create build logs if they don't exist
        const buildLogCreated = await createEmptyBuildLog(path.join(baseDir, config.buildLog));
        const localBuildLogCreated = await createEmptyBuildLog(
          path.join(baseDir, config.localBuildLog)
        );

        if (buildLogCreated) console.log('‚úÖ Created build log');
        if (localBuildLogCreated) console.log('‚úÖ Created local build log');

        // Update gitignore
        const gitignorePath = path.join(baseDir, '.gitignore');
        const ignoreEntry = config.localBuildLog;

        let content = '';
        try {
          content = await fs.readFile(gitignorePath, 'utf-8');
        } catch {
          // Ignore
        }

        if (!content.includes(ignoreEntry)) {
          content = content.trim() + '\n' + ignoreEntry + '\n';
          await fs.writeFile(gitignorePath, content);
          console.log('‚úÖ Updated .gitignore');
        } else {
          console.log('‚è≠Ô∏è .gitignore already updated');
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize:', error);
        process.exit(1);
      }
    }
    doInit();
  }, []);

  return null;
}

================
File: commands/register.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { MultiSelect } from '@inkjs/ui';
import { useTemplateState } from '../hooks/useTemplateState.js';
import { registerTemplate } from '../utils/registerTemplate.js';
import { argument } from 'pastel';
import zod from 'zod';

// Support both array of filenames as arguments and interactive selection
export const args = zod
  .array(zod.string())
  .optional()
  .describe(
    argument({
      name: 'templates',
      description: 'Template files to register (optional)',
    })
  );

type Props = {
  args: zod.infer<typeof args>;
};

export default function Register({ args: templateArgs }: Props) {
  const { error, items } = useTemplateState();
  const [selectedValues, setSelectedValues] = React.useState<string[]>([]);
  const [successMessage, setSuccessMessage] = React.useState('');
  const [errorMessage, setErrorMessage] = React.useState('');

  const handleTemplateRegistration = React.useCallback(async (templates: string[]) => {
    setSuccessMessage('');
    setErrorMessage('');

    let successCount = 0;
    let failCount = 0;

    for (const path of templates) {
      try {
        await registerTemplate(path, process.cwd());
        successCount++;
      } catch {
        failCount++;
      }
    }

    if (failCount > 0) {
      setErrorMessage(`Failed to register ${failCount} template(s).`);
    }
    if (successCount > 0) {
      setSuccessMessage(`Successfully registered ${successCount} template(s).`);
    }

    process.exit(failCount > 0 ? 1 : 0);
  }, []);

  React.useEffect(() => {
    // If templates were provided as arguments, register them directly
    if (templateArgs?.length) {
      void handleTemplateRegistration(templateArgs);
    }
  }, [handleTemplateRegistration, templateArgs]);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  // If no templates were provided as arguments, show interactive selection
  if (templateArgs?.length === 0) {
    const options = items.map(t => {
      const status = t.buildState.lastMigrationFile ? 'registered' : 'new';
      return {
        label: `${t.name} (${status})`,
        value: t.path,
      };
    });

    return (
      <Box flexDirection="column">
        <Text bold>Register Templates</Text>
        <Text>Use arrow/space to select, then press Enter to register.</Text>
        <Box marginTop={1}>
          <Text color="white">
            {selectedValues.length} / {options.length} selected
          </Text>
        </Box>
        <Box marginTop={1} marginBottom={1}>
          <MultiSelect
            options={options}
            onChange={vals => setSelectedValues(vals)}
            onSubmit={vals => void handleTemplateRegistration(vals)}
          />
        </Box>
        {!!errorMessage && <Text color="red">{errorMessage}</Text>}
        {!!successMessage && <Text color="green">{successMessage}</Text>}
      </Box>
    );
  }

  return (
    <Box flexDirection="column" marginTop={1}>
      {!!errorMessage && <Text color="red">{errorMessage}</Text>}
      {!!successMessage && <Text color="green">{successMessage}</Text>}
    </Box>
  );
}

================
File: commands/status.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import path from 'path';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { getTimeAgo } from '../utils/getTimeAgo.js';
import { loadTemplates } from '../utils/loadTemplates.js';
import { TemplateStatus, TemplateStateInfo } from '../types.js';
import { calculateTemplateState } from '../utils/templateState.js';
import { StatusIndicator } from '../components/StatusIndicator.js';

interface TemplateWithState {
  template: TemplateStatus;
  state: TemplateStateInfo;
}

export default function Status() {
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [templateStates, setTemplateStates] = React.useState<TemplateWithState[]>([]);

  React.useEffect(() => {
    async function fetchStatus() {
      try {
        const dirname = process.cwd();
        const templates = await loadTemplates(dirname);
        const buildLog = await loadBuildLog(dirname, 'common');
        const localBuildLog = await loadBuildLog(dirname, 'local');

        const combined: TemplateStatus[] = templates.map(t => {
          const relPath = path.relative(dirname, t.path);
          const buildState = {
            ...buildLog.templates[relPath],
            ...localBuildLog.templates[relPath],
          };

          return {
            name: t.name,
            path: relPath,
            currentHash: t.currentHash,
            migrationHash: t.migrationHash,
            buildState,
          };
        });

        // Calculate states for all templates
        const states = await Promise.all(
          combined.map(async item => ({
            template: item,
            state: await calculateTemplateState(item),
          }))
        );
        setTemplateStates(states);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  const formatDate = (date?: string) => {
    if (!date) return 'Never';
    return getTimeAgo(new Date(date));
  };

  if (loading) return <Text>Loading status‚Ä¶</Text>;
  if (error) return <Text color="red">Error: {error}</Text>;

  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Template Status</Text>
      </Box>

      <Box marginY={1}>
        <Box width={25}>
          <Text bold>Template</Text>
        </Box>
        <Box width={15}>
          <Text bold>Build Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Apply Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Built</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Applied</Text>
        </Box>
      </Box>

      {templateStates.map(({ template, state }) => (
        <Box key={template.path} flexDirection="column">
          <Box>
            <Box width={25}>
              <Text>{template.name}</Text>
            </Box>
            <StatusIndicator state={state} />
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastBuildDate)}</Text>
            </Box>
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastAppliedDate)}</Text>
            </Box>
          </Box>
          {(state.buildMessage || state.applyMessage) && (
            <Box marginLeft={2} marginBottom={1}>
              {state.buildMessage && <Text color="red">Build: {state.buildMessage}</Text>}
              {state.applyMessage && <Text color="red">Apply: {state.applyMessage}</Text>}
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
}

================
File: commands/watch.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { watch } from 'fs';
import { access } from 'fs/promises';
import path from 'path';
import { getConfig } from '../utils/config.js';
import { applyPendingTemplates } from '../utils/applyPendingTemplates.js';

export default function Watch() {
  const [status, setStatus] = React.useState<string>('Initializing...');
  const [error, setError] = React.useState<string | null>(null);
  const [lastBuild, setLastBuild] = React.useState<Date | null>(null);

  React.useEffect(() => {
    let debounceTimer: NodeJS.Timeout;
    let watcher: ReturnType<typeof watch>;

    const handleExit = () => {
      setStatus('Shutting down...');
      if (debounceTimer) clearTimeout(debounceTimer);
      if (watcher) watcher.close();
      process.exit(0);
    };

    process.on('SIGINT', handleExit);

    async function init(): Promise<void> {
      try {
        const baseDir = process.cwd();
        const config = await getConfig(baseDir);
        const templatePath = path.join(baseDir, config.templateDir);

        try {
          await access(templatePath);
        } catch {
          throw new Error('Template directory not found. Run init first.');
        }

        setStatus('Checking for unapplied templates...');
        await applyPendingTemplates(baseDir);
        setStatus('Watching for changes...');

        const handleChange = async (_: string, filename: string | null) => {
          if (!filename?.endsWith('.sql')) return;

          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(async () => {
            try {
              setStatus(`Building ${filename}...`);
              const result = await applyPendingTemplates(baseDir, filename);

              if (result.errors.length > 0) {
                setError(result.errors.map(e => `${e.file}: ${e.error}`).join('\n'));
              } else {
                setError(null);
                if (result.applied.length > 0) {
                  setLastBuild(new Date());
                }
              }
            } catch (err) {
              setError(err instanceof Error ? err.message : 'Unknown error');
            } finally {
              setStatus('Watching for changes...');
            }
          }, 100);
        };

        watcher = watch(templatePath, { recursive: true }, handleChange);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
        setStatus('Watch failed');
      }
    }

    init();

    return () => {
      process.off('SIGINT', handleExit);
      if (debounceTimer) clearTimeout(debounceTimer);
      if (watcher) watcher.close();
    };
  }, []);

  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text color={error ? 'red' : 'white'}>{status}</Text>
      </Box>
      {error && (
        <Box marginBottom={1}>
          <Text color="red">Error: {error}</Text>
        </Box>
      )}
      {lastBuild && (
        <Box>
          <Text dimColor>Last build: {lastBuild.toLocaleTimeString()}</Text>
        </Box>
      )}
    </Box>
  );
}

================
File: components/StatusIndicator.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { TemplateStateInfo } from '../types.js';
import {
  getBuildStatusColor,
  getApplyStatusColor,
  getApplyStatusIcon,
  getBuildStatusIcon,
} from '../utils/templateState.js';

interface StatusIndicatorProps {
  state: TemplateStateInfo;
}

export function StatusIndicator({ state }: StatusIndicatorProps) {
  // Move existing getStatusIndicator here
  return (
    <Box>
      <Box width={15}>
        <Text color={getBuildStatusColor(state.buildStatus)}>
          {getBuildStatusIcon(state.buildStatus)}
        </Text>
      </Box>
      <Box width={15}>
        <Text color={getApplyStatusColor(state.applyStatus)}>
          {getApplyStatusIcon(state.applyStatus)}
        </Text>
      </Box>
    </Box>
  );
}

================
File: components/TemplateList.tsx
================
import React, { useEffect, useState } from 'react';
import { Box, Text } from 'ink';
import { TemplateStatus, TemplateStateInfo } from '../types.js';
import { StatusIndicator } from './StatusIndicator.js';
import { calculateTemplateState } from '../utils/templateState.js';
import { getTimeAgo } from '../utils/getTimeAgo.js';

interface TemplateListProps {
  items: TemplateStatus[];
}

interface TemplateWithState {
  template: TemplateStatus;
  state: TemplateStateInfo;
}

export function TemplateList({ items }: TemplateListProps) {
  const [templateStates, setTemplateStates] = useState<TemplateWithState[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadStates = async () => {
      const states = await Promise.all(
        items.map(async item => ({
          template: item,
          state: await calculateTemplateState(item),
        }))
      );
      setTemplateStates(states);
      setIsLoading(false);
    };
    loadStates();
  }, [items]);

  const formatDate = (date?: string) => {
    if (!date) return 'Never';
    return getTimeAgo(new Date(date));
  };

  if (isLoading) {
    return (
      <Box>
        <Text>Loading templates...</Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      {/* Header */}
      <Box marginY={1}>
        <Box width={25}>
          <Text bold>Template</Text>
        </Box>
        <Box width={15}>
          <Text bold>Build Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Apply Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Built</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Applied</Text>
        </Box>
      </Box>

      {/* Items */}
      {templateStates.map(({ template, state }) => (
        <Box key={template.path} flexDirection="column">
          <Box>
            <Box width={25}>
              <Text>{template.name}</Text>
            </Box>
            <StatusIndicator state={state} />
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastBuildDate)}</Text>
            </Box>
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastAppliedDate)}</Text>
            </Box>
          </Box>
          {/* Error messages */}
          {(state.buildMessage || state.applyMessage) && (
            <Box marginLeft={2} marginBottom={1}>
              {state.buildMessage && <Text color="red">Build: {state.buildMessage}</Text>}
              {state.applyMessage && <Text color="red">Apply: {state.applyMessage}</Text>}
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
}

================
File: db-diff-checks/.gitignore
================
/diffs

================
File: db-diff-checks/compare_db_state.sh
================
#!/bin/bash

# Configuration
DB_URL="postgresql://postgres:postgres@localhost:54322/postgres"
OUTPUT_DIR="./scripts/db-diff-checks/diffs"
REPORT_DIR="${OUTPUT_DIR}/reports"

# Create output directories
mkdir -p "$OUTPUT_DIR"
mkdir -p "$REPORT_DIR"

# Colors for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

generate_markdown_report() {
    local TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    local REPORT_FILE="${REPORT_DIR}/comparison_${TIMESTAMP}.md"
    local HAS_CHANGES=0

    # Create report header
    cat > "$REPORT_FILE" << EOF
# Database State Comparison Report
Generated: $(date)

EOF

    # Add each comparison to the report
    for TYPE in functions enums tables rls triggers views indexes extensions types sequences default_privs comments; do
            echo "## $(echo $TYPE | tr '[:lower:]' '[:upper:]')" >> "$REPORT_FILE"
            if diff --unified "${OUTPUT_DIR}/before_${TYPE}.txt" "${OUTPUT_DIR}/after_${TYPE}.txt" > /dev/null; then
                echo "‚úì No changes detected" >> "$REPORT_FILE"
            else
            HAS_CHANGES=1
            echo "‚ö†Ô∏è Changes detected:" >> "$REPORT_FILE"
            echo "\`\`\`diff" >> "$REPORT_FILE"
            diff --unified "${OUTPUT_DIR}/before_${TYPE}.txt" "${OUTPUT_DIR}/after_${TYPE}.txt" | \
                grep -v "^@@" >> "$REPORT_FILE"
            echo "\`\`\`" >> "$REPORT_FILE"
        fi
        echo >> "$REPORT_FILE"
    done

    if [ $HAS_CHANGES -eq 1 ]; then
        echo "Report generated: $REPORT_FILE"
        echo "Opening report..."
        if [[ "$OSTYPE" == "darwin"* ]]; then
            open "$REPORT_FILE"
        elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
            xdg-open "$REPORT_FILE"
        fi
    else
        rm "$REPORT_FILE"
        echo "No changes detected - no report generated"
    fi
}
compare_states() {
    echo "=== Database State Comparison ==="
    echo

    local HAS_DIFFERENCES=0

    for TYPE in functions enums tables rls triggers views indexes extensions types sequences default_privs comments; do
        echo "=== Comparing $TYPE ==="

        if diff --color=always -u "${OUTPUT_DIR}/before_${TYPE}.txt" "${OUTPUT_DIR}/after_${TYPE}.txt" > /dev/null; then
            echo -e "${GREEN}‚úì No changes detected${NC}"
        else
            echo -e "${RED}! Changes detected:${NC}"
            echo
            # Show changes in terminal
            diff --color=always -u "${OUTPUT_DIR}/before_${TYPE}.txt" \
                         "${OUTPUT_DIR}/after_${TYPE}.txt" | \
                grep -v "^@@" | \
                grep -v "^---" | \
                grep -v "^+++"
            HAS_DIFFERENCES=1
        fi
        echo
    done

    # Only generate report if there are differences
    if [ $HAS_DIFFERENCES -eq 1 ]; then
        local TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        local REPORT_FILE="${REPORT_DIR}/comparison_${TIMESTAMP}.md"

        # Create report header
        cat > "$REPORT_FILE" << EOF
# Database State Comparison Report
Generated: $(date)

EOF

        # Add each section to the report
        for TYPE in functions enums tables rls triggers views indexes extensions types sequences default_privs comments; do
            echo "## ${TYPE^}" >> "$REPORT_FILE"
            if diff --unified "${OUTPUT_DIR}/before_${TYPE}.txt" "${OUTPUT_DIR}/after_${TYPE}.txt" > /dev/null; then
                echo "‚úì No changes detected" >> "$REPORT_FILE"
            else
                echo "‚ö†Ô∏è Changes detected:" >> "$REPORT_FILE"
                echo "\`\`\`diff" >> "$REPORT_FILE"
                diff --unified "${OUTPUT_DIR}/before_${TYPE}.txt" "${OUTPUT_DIR}/after_${TYPE}.txt" | \
                    grep -v "^@@" >> "$REPORT_FILE"
                echo "\`\`\`" >> "$REPORT_FILE"
            fi
            echo >> "$REPORT_FILE"
        done

        echo "Report generated: $REPORT_FILE"

        # Try to open the report, preferring other editors over Xcode
        if [[ "$OSTYPE" == "darwin"* ]]; then
            if command -v code >/dev/null 2>&1; then
                code "$REPORT_FILE"  # Try VS Code first
            elif command -v subl >/dev/null 2>&1; then
                subl "$REPORT_FILE"  # Try Sublime Text second
            else
                echo "Report available at: $REPORT_FILE"
                # Removed 'open' command to avoid Xcode
            fi
        elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
            xdg-open "$REPORT_FILE" || echo "Report available at: $REPORT_FILE"
        else
            echo "Report available at: $REPORT_FILE"
        fi
    fi
}

dump_state() {
    local PREFIX=$1
    local OUTFILE="$OUTPUT_DIR/${PREFIX}"

    echo "Dumping database state..."

    # Debug: Create empty files first
    for TYPE in functions enums tables rls triggers views indexes extensions types sequences default_privs comments; do
        echo "NO_CONTENT" > "${OUTFILE}_${TYPE}.txt"
    done

# Functions
    psql "$DB_URL" -t -A -c "
        WITH function_comments AS (
            SELECT
                d.objoid,
                d.description
            FROM pg_description d
            JOIN pg_proc p ON p.oid = d.objoid
            WHERE d.objsubid = 0
        )
        SELECT format(
            'FUNCTION: %s.%s(%s)\nRETURN TYPE: %s\nARGUMENTS: %s\nCOMMENT: %s\nVOLATILITY: %s\n%s\n---\n',
            nspname,
            proname,
            pg_get_function_arguments(p.oid),
            pg_get_function_result(p.oid),
            pg_get_function_identity_arguments(p.oid),
            COALESCE(fc.description, '(no comment)'),
            CASE provolatile
                WHEN 'i' THEN 'IMMUTABLE'
                WHEN 's' THEN 'STABLE'
                WHEN 'v' THEN 'VOLATILE'
            END,
            pg_get_functiondef(p.oid)
        )
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        LEFT JOIN function_comments fc ON fc.objoid = p.oid
        WHERE nspname = 'public'
        ORDER BY nspname, proname;" > "${OUTFILE}_functions.txt"

# Enums
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'TYPE: %s (ENUM)\nVALUES:\n%s\n---\n',
            t.typname,
            string_agg(
                format('  - %s', e.enumlabel),
                E'\n' ORDER BY e.enumsortorder
            )
        )
        FROM pg_type t
        JOIN pg_enum e ON t.oid = e.enumtypid
        JOIN pg_namespace n ON t.typnamespace = n.oid
        WHERE n.nspname = 'public'
        GROUP BY t.typname, n.nspname
        ORDER BY t.typname;" > "${OUTFILE}_enums.txt"

# Tables
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'TABLE: %s\n%s\n---\n',
            c.relname,
            pg_catalog.pg_get_tabledef(c.oid)
        )
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'public'
        AND c.relkind = 'r'
        ORDER BY c.relname;" > "${OUTFILE}_tables.txt" 2>/dev/null || \
    # Fallback if pg_get_tabledef is not available
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'TABLE: %s\n%s\n---\n',
            tablename,
            (
                SELECT string_agg(
                    format('%s %s', column_name, data_type),
                    E'\n'
                )
                FROM information_schema.columns c2
                WHERE c2.table_name = c1.tablename
                AND c2.table_schema = 'public'
            )
        )
        FROM pg_tables c1
        WHERE schemaname = 'public'
        ORDER BY tablename;" > "${OUTFILE}_tables.txt"

# RLS Policies
    psql "$DB_URL" -t -A -c "
        WITH policy_roles AS (
            SELECT
                polname,
                relname,
                string_agg(
                    CASE
                        WHEN r.rolname IS NULL THEN 'public'
                        ELSE quote_ident(r.rolname)
                    END,
                    ', ' ORDER BY r.rolname
                ) as grantee_roles
            FROM pg_policy pol
            JOIN pg_class c ON c.oid = pol.polrelid
            LEFT JOIN LATERAL unnest(pol.polroles) AS rid(rid) ON true
            LEFT JOIN pg_roles r ON r.oid = rid.rid
            GROUP BY polname, relname
        )
        SELECT format(
            'POLICY: %s\nON TABLE: %s\nCOMMAND: %s\nROLES: %s\nUSING: %s\nWITH CHECK: %s\n---\n',
            pol.polname,
            c.relname,
            CASE pol.polcmd
                WHEN 'r' THEN 'SELECT'
                WHEN 'a' THEN 'INSERT'
                WHEN 'w' THEN 'UPDATE'
                WHEN 'd' THEN 'DELETE'
                WHEN '*' THEN 'ALL'
            END,
            COALESCE(pr.grantee_roles, 'public'),
            NULLIF(pg_get_expr(pol.polqual, pol.polrelid), ''),
            NULLIF(pg_get_expr(pol.polwithcheck, pol.polrelid), '')
        )
        FROM pg_policy pol
        JOIN pg_class c ON c.oid = pol.polrelid
        LEFT JOIN policy_roles pr ON pr.polname = pol.polname AND pr.relname = c.relname
        WHERE c.relnamespace = 'public'::regnamespace
        ORDER BY c.relname, pol.polname;" > "${OUTFILE}_rls.txt"

# Triggers
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'TRIGGER: %s\nTABLE: %s\nTIMING: %s\nEVENTS: %s\nDEFINITION:\n%s\n---\n',
            tgname,
            relname,
            CASE tgtype & 2
                WHEN 0 THEN 'AFTER'
                ELSE 'BEFORE'
            END,
            string_agg(
                CASE
                    WHEN tgtype & 4 > 0 THEN 'INSERT'
                    WHEN tgtype & 8 > 0 THEN 'DELETE'
                    WHEN tgtype & 16 > 0 THEN 'UPDATE'
                    WHEN tgtype & 32 > 0 THEN 'TRUNCATE'
                END,
                ' OR '
            ),
            pg_get_triggerdef(t.oid)
        )
        FROM pg_trigger t
        JOIN pg_class c ON t.tgrelid = c.oid
        WHERE NOT tgisinternal
        AND relnamespace = 'public'::regnamespace
        GROUP BY t.oid, tgname, relname, tgtype
        ORDER BY relname, tgname;" > "${OUTFILE}_triggers.txt"

    # Views
    psql "$DB_URL" -t -A -c "
        WITH view_grants AS (
            SELECT table_name,
                   string_agg(DISTINCT grantee || ': ' || privilege_type, ', ') as grants
            FROM information_schema.role_table_grants
            WHERE table_schema = 'public'
            GROUP BY table_name
        )
        SELECT format(
            'VIEW: %s\nTYPE: %s\nOWNER: %s\nDEFINITION:\n%s\nGRANTS:\n%s\n---\n',
            c.relname,
            CASE c.relkind WHEN 'v' THEN 'VIEW' ELSE 'MATERIALIZED VIEW' END,
            pg_get_userbyid(c.relowner),
            pg_get_viewdef(c.oid),
            COALESCE(g.grants, 'No explicit grants')
        )
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        LEFT JOIN view_grants g ON g.table_name = c.relname
        WHERE n.nspname = 'public'
        AND c.relkind IN ('v', 'm')
        ORDER BY c.relname;" > "${OUTFILE}_views.txt"

    # Indexes
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'INDEX: %s\nON TABLE: %s\nTYPE: %s\nDEFINITION:\n%s\n---\n',
            i.relname,
            t.relname,
            am.amname,
            pg_get_indexdef(i.oid)
        )
        FROM pg_class i
        JOIN pg_index idx ON idx.indexrelid = i.oid
        JOIN pg_class t ON t.oid = idx.indrelid
        JOIN pg_am am ON am.oid = i.relam
        JOIN pg_namespace n ON n.oid = i.relnamespace
        WHERE n.nspname = 'public'
        AND i.relkind = 'i'
        ORDER BY t.relname, i.relname;" > "${OUTFILE}_indexes.txt"

    # Extensions
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'EXTENSION: %s\nVERSION: %s\nSCHEMA: %s\n---\n',
            extname,
            extversion,
            n.nspname
        )
        FROM pg_extension e
        JOIN pg_namespace n ON n.oid = e.extnamespace
        ORDER BY extname;" > "${OUTFILE}_extensions.txt"

    # Types
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'TYPE: %s\nCATEGORY: %s\nDEFINITION:\n%s\n---\n',
            t.typname,
            t.typcategory::text,
            pg_catalog.format_type(t.oid, NULL)
        )
        FROM pg_type t
        JOIN pg_namespace n ON n.oid = t.typnamespace
        WHERE n.nspname = 'public'
        AND t.typtype NOT IN ('e')
        ORDER BY t.typname;" > "${OUTFILE}_types.txt"

    # Sequences
    psql "$DB_URL" -t -A -c "
        WITH seq_owned AS (
            SELECT
                d.refobjid::regclass AS table_name,
                a.attname AS column_name,
                d.objid::regclass AS sequence_name
            FROM pg_depend d
            JOIN pg_attribute a ON a.attrelid = d.refobjid AND a.attnum = d.refobjsubid
            WHERE d.classid = 'pg_class'::regclass
            AND d.refclassid = 'pg_class'::regclass
            AND d.deptype = 'a'
        )
        SELECT format(
            'SEQUENCE: %s\nOWNED BY: %s\nSTART: %s\nINCREMENT: %s\nMIN: %s\nMAX: %s\nCYCLE: %s\n---\n',
            c.relname,
            COALESCE(
                (SELECT format('%s.%s', table_name, column_name)
                FROM seq_owned
                WHERE sequence_name::text = c.relname
                LIMIT 1
            ), 'none'),
            s.seqstart,
            s.seqincrement,
            s.seqmin,
            s.seqmax,
            CASE WHEN s.seqcycle THEN 'yes' ELSE 'no' END
        )
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        JOIN pg_sequence s ON s.seqrelid = c.oid
        WHERE n.nspname = 'public'
        AND c.relkind = 'S'
        ORDER BY c.relname;" > "${OUTFILE}_sequences.txt"


    # Default Privileges
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'DEFAULT PRIVILEGE: %s\nGRANTOR: %s\nGRANTEE: %s\nOBJECT TYPE: %s\nPRIVILEGES: %s\n---\n',
            defaclnamespace::regnamespace,
            r1.rolname,
            r2.rolname,
            CASE defaclobjtype
                WHEN 'r' THEN 'TABLE'
                WHEN 'S' THEN 'SEQUENCE'
                WHEN 'f' THEN 'FUNCTION'
                WHEN 'T' THEN 'TYPE'
                WHEN 'n' THEN 'SCHEMA'
            END,
            defaclacl::text
        )
        FROM pg_default_acl d
        JOIN pg_roles r1 ON r1.oid = d.defaclrole
        JOIN pg_roles r2 ON r2.oid = d.defaclrole
        WHERE defaclnamespace::regnamespace::text = 'public'
        ORDER BY defaclobjtype;" > "${OUTFILE}_default_privs.txt"

    # Comments
    psql "$DB_URL" -t -A -c "
        SELECT format(
            'COMMENT ON %s %s: %s\n---\n',
            CASE c.relkind
                WHEN 'r' THEN 'TABLE'
                WHEN 'v' THEN 'VIEW'
                WHEN 'f' THEN 'FOREIGN TABLE'
                WHEN 'i' THEN 'INDEX'
                WHEN 'S' THEN 'SEQUENCE'
                ELSE c.relkind::text
            END,
            c.relname,
            d.description
        )
        FROM pg_description d
        JOIN pg_class c ON c.oid = d.objoid
        JOIN pg_namespace n ON n.oid = c.relnamespace
        WHERE n.nspname = 'public'
        AND d.objsubid = 0
        ORDER BY c.relkind, c.relname;" > "${OUTFILE}_comments.txt"

    # Functions with comments
    psql "$DB_URL" -t -A -c "
        WITH function_comments AS (
            SELECT
                d.objoid,
                d.description
            FROM pg_description d
            JOIN pg_proc p ON p.oid = d.objoid
            WHERE d.objsubid = 0
        )
        SELECT format(
            'FUNCTION: %s.%s\nRETURN TYPE: %s\nCOMMENT: %s\n%s\n---\n',
            nspname,
            proname,
            pg_get_function_result(p.oid),
            COALESCE(fc.description, '(no comment)'),
            pg_get_functiondef(p.oid)
        )
        FROM pg_proc p
        JOIN pg_namespace n ON p.pronamespace = n.oid
        LEFT JOIN function_comments fc ON fc.objoid = p.oid
        WHERE nspname = 'public'
        ORDER BY nspname, proname;" > "${OUTFILE}_functions.txt"

    # Touch empty files if they don't exist (for empty results)
    for TYPE in functions enums tables rls triggers views indexes extensions types sequences default_privs comments; do
        touch "${OUTFILE}_${TYPE}.txt"
    done

    echo "‚úì State dump completed"
}
case "$1" in
    "before")
        dump_state "before"
        ;;
    "after")
        if [ ! -f "${OUTPUT_DIR}/before_functions.txt" ]; then
            echo "Error: No 'before' state found. Run with 'before' first."
            exit 1
        fi
        dump_state "after" && compare_states
        ;;
    "view")
        if [ ! -f "${OUTPUT_DIR}/before_functions.txt" ]; then
            echo "Error: No states found. Run with 'before' first."
            exit 1
        fi
        less "${OUTPUT_DIR}/before_functions.txt"
        ;;
    *)
        echo "Usage: $0 {before|after|view}"
        echo "  before: Dump initial state before migrations"
        echo "  after:  Dump final state after migrations and show differences"
        echo "  view:   View the current function definitions"
        exit 1
        ;;
esac

================
File: db-diff-checks/test_db_compare.sh
================
#!/bin/bash

# Configuration
DB_URL="postgresql://postgres:postgres@localhost:54322/postgres"
SCRIPT_DIR="./scripts/db-diff-checks"
COMPARE_SCRIPT="${SCRIPT_DIR}/compare_db_state.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

# Test counter
TESTS_PASSED=0
TESTS_FAILED=0

run_test() {
    local test_name=$1
    local setup_sql=$2
    local cleanup_sql=$3
    local object_type=$4

    echo -e "${BLUE}Running test: ${test_name}${NC}"

    # Take initial snapshot
    $COMPARE_SCRIPT before > /dev/null 2>&1

    # Apply changes
    echo "$setup_sql" | psql "$DB_URL" > /dev/null 2>&1

    # Compare states
    $COMPARE_SCRIPT after > test_output.txt 2>&1

    # Look for any changes in the specified object type
    if grep -q "=== Comparing ${object_type} ===" test_output.txt && \
       grep -A 1 "=== Comparing ${object_type} ===" test_output.txt | grep -q "! Changes detected"; then
        echo -e "${GREEN}‚úì Test passed: Changes detected in ${object_type}${NC}"
        TESTS_PASSED=$((TESTS_PASSED + 1))
    else
        echo -e "${RED}‚úó Test failed: No changes detected in ${object_type}${NC}"
        TESTS_FAILED=$((TESTS_FAILED + 1))
        echo "Test output:"
        cat test_output.txt
    fi
    echo

    # Cleanup
    echo "$cleanup_sql" | psql "$DB_URL" > /dev/null 2>&1
    rm -f test_output.txt
}

# Core Functionality Tests
run_test "RLS Policy - Role Changes" \
"ALTER POLICY \"tools:authenticated:-r--\" ON public.tools TO authenticated, service_role, anon;" \
"ALTER POLICY \"tools:authenticated:-r--\" ON public.tools TO authenticated, anon;" \
"rls"

run_test "RLS Policy - Condition Changes" \
"CREATE POLICY test_policy ON public.tools FOR SELECT USING (true);
ALTER POLICY test_policy ON public.tools USING (false);" \
"DROP POLICY test_policy ON public.tools;" \
"rls"

run_test "RLS Policy - Command Changes" \
"CREATE POLICY test_policy ON public.tools FOR SELECT USING (true);
DROP POLICY test_policy ON public.tools;
CREATE POLICY test_policy ON public.tools FOR INSERT WITH CHECK (true);" \
"DROP POLICY test_policy ON public.tools;" \
"rls"

# Function Tests
run_test "Function - Basic Creation" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS trigger AS \$\$
BEGIN
    RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

run_test "Function - Argument Changes" \
"CREATE OR REPLACE FUNCTION public.test_func(arg1 text) RETURNS void AS \$\$
BEGIN
    NULL;
END;
\$\$ LANGUAGE plpgsql;
DROP FUNCTION public.test_func(text);
CREATE OR REPLACE FUNCTION public.test_func(arg1 text, arg2 int) RETURNS void AS \$\$
BEGIN
    NULL;
END;
\$\$ LANGUAGE plpgsql;" \
"DROP FUNCTION IF EXISTS public.test_func(text, int);" \
"functions"

run_test "Function - Return Type Changes" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS text AS \$\$
BEGIN
    RETURN 'test';
END;
\$\$ LANGUAGE plpgsql;" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

run_test "Function - Body Changes" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS text AS \$\$
BEGIN
    RETURN 'test1';
END;
\$\$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION public.test_func() RETURNS text AS \$\$
BEGIN
    RETURN 'test2';
END;
\$\$ LANGUAGE plpgsql;" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

run_test "Function - Language Changes" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS text AS \$\$
BEGIN
    RETURN 'test';
END;
\$\$ LANGUAGE plpgsql;
DROP FUNCTION public.test_func();
CREATE OR REPLACE FUNCTION public.test_func() RETURNS text AS \$\$
    SELECT 'test'
\$\$ LANGUAGE sql;" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

run_test "Function - Volatility Changes" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS text VOLATILE AS \$\$
BEGIN
    RETURN 'test';
END;
\$\$ LANGUAGE plpgsql;
DROP FUNCTION public.test_func();
CREATE OR REPLACE FUNCTION public.test_func() RETURNS text IMMUTABLE AS \$\$
BEGIN
    RETURN 'test';
END;
\$\$ LANGUAGE plpgsql;" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

run_test "Function - Comment Changes" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS void AS \$\$
BEGIN
    NULL;
END;
\$\$ LANGUAGE plpgsql;
COMMENT ON FUNCTION public.test_func() IS 'Initial comment';" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

# Enum Tests
run_test "Enum - Basic Creation" \
"CREATE TYPE public.test_enum AS ENUM ('value1', 'value2');" \
"DROP TYPE IF EXISTS public.test_enum;" \
"enums"

run_test "Enum - Add Value" \
"CREATE TYPE public.test_enum AS ENUM ('value1', 'value2');
ALTER TYPE public.test_enum ADD VALUE 'value3';" \
"DROP TYPE IF EXISTS public.test_enum;" \
"enums"

run_test "Enum - Recreate With Different Values" \
"CREATE TYPE public.test_enum AS ENUM ('value1', 'value2');
DROP TYPE public.test_enum;
CREATE TYPE public.test_enum AS ENUM ('value3', 'value4');" \
"DROP TYPE IF EXISTS public.test_enum;" \
"enums"

# Table Tests
run_test "Table - Column Addition" \
"CREATE TABLE public.test_table (id int);
ALTER TABLE public.test_table ADD COLUMN name text;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Column Type Change" \
"CREATE TABLE public.test_table (id int);
ALTER TABLE public.test_table ALTER COLUMN id TYPE bigint;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Default Value Changes" \
"CREATE TABLE public.test_table (id int DEFAULT 0);
ALTER TABLE public.test_table ALTER COLUMN id SET DEFAULT 1;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Constraint Addition" \
"CREATE TABLE public.test_table (id int);
ALTER TABLE public.test_table ADD CONSTRAINT test_check CHECK (id > 0);" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Primary Key Changes" \
"CREATE TABLE public.test_table (id int, name text);
ALTER TABLE public.test_table ADD PRIMARY KEY (id);
ALTER TABLE public.test_table DROP CONSTRAINT test_table_pkey;
ALTER TABLE public.test_table ADD PRIMARY KEY (id, name);" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

# Trigger Tests
run_test "Trigger - Basic Creation" \
"CREATE OR REPLACE FUNCTION public.test_trigger_func() RETURNS trigger AS \$\$ BEGIN RETURN NEW; END; \$\$ LANGUAGE plpgsql;
CREATE TRIGGER test_trigger AFTER INSERT ON public.tools FOR EACH ROW EXECUTE FUNCTION public.test_trigger_func();" \
"DROP TRIGGER IF EXISTS test_trigger ON public.tools; DROP FUNCTION IF EXISTS public.test_trigger_func();" \
"triggers"

run_test "Trigger - Condition Changes" \
"CREATE OR REPLACE FUNCTION public.test_trigger_func() RETURNS trigger AS \$\$ BEGIN RETURN NEW; END; \$\$ LANGUAGE plpgsql;
CREATE TRIGGER test_trigger AFTER INSERT ON public.tools FOR EACH ROW WHEN (true) EXECUTE FUNCTION public.test_trigger_func();
DROP TRIGGER test_trigger ON public.tools;
CREATE TRIGGER test_trigger AFTER INSERT ON public.tools FOR EACH ROW WHEN (false) EXECUTE FUNCTION public.test_trigger_func();" \
"DROP TRIGGER IF EXISTS test_trigger ON public.tools; DROP FUNCTION IF EXISTS public.test_trigger_func();" \
"triggers"

# View Tests
run_test "View - Basic Creation" \
"CREATE VIEW public.test_view AS SELECT 1 as num;" \
"DROP VIEW IF EXISTS public.test_view;" \
"views"

run_test "View - Definition Changes" \
"CREATE VIEW public.test_view AS SELECT 1 as num;
CREATE OR REPLACE VIEW public.test_view AS SELECT 2 as num;" \
"DROP VIEW IF EXISTS public.test_view;" \
"views"

run_test "View - Column Names" \
"CREATE VIEW public.test_view AS SELECT 1 as num;
DROP VIEW public.test_view;
CREATE VIEW public.test_view AS SELECT 1 as different_name;" \
"DROP VIEW IF EXISTS public.test_view;" \
"views"

# Index Tests
run_test "Index - Basic Creation" \
"CREATE TABLE IF NOT EXISTS public.test_table (name text);
CREATE INDEX test_idx ON public.test_table (name);" \
"DROP TABLE IF EXISTS public.test_table CASCADE;" \
"indexes"

run_test "Index - Expression Changes" \
"CREATE TABLE IF NOT EXISTS public.test_table (name text);
CREATE INDEX test_idx ON public.test_table (lower(name));" \
"DROP TABLE IF EXISTS public.test_table CASCADE;" \
"indexes"

run_test "Index - Type Changes" \
"CREATE TABLE IF NOT EXISTS public.test_table (name text);
CREATE INDEX test_idx ON public.test_table USING hash (name);" \
"DROP TABLE IF EXISTS public.test_table CASCADE;" \
"indexes"

# Comment Tests
run_test "Comment - Table Comments" \
"CREATE TABLE public.test_table (id int);
COMMENT ON TABLE public.test_table IS 'First comment';
COMMENT ON TABLE public.test_table IS 'Changed comment';" \
"DROP TABLE IF EXISTS public.test_table;" \
"comments"

run_test "Comment - Column Comments" \
"CREATE TABLE public.test_table (id int);
COMMENT ON COLUMN public.test_table.id IS 'First comment';" \
"DROP TABLE IF EXISTS public.test_table CASCADE;" \
"tables"

run_test "Comment - Function Comments" \
"CREATE OR REPLACE FUNCTION public.test_func() RETURNS void AS \$\$ BEGIN NULL; END; \$\$ LANGUAGE plpgsql;
COMMENT ON FUNCTION public.test_func() IS 'First comment';
DROP FUNCTION public.test_func();
CREATE OR REPLACE FUNCTION public.test_func() RETURNS void AS \$\$ BEGIN NULL; END; \$\$ LANGUAGE plpgsql;
COMMENT ON FUNCTION public.test_func() IS 'Changed comment';" \
"DROP FUNCTION IF EXISTS public.test_func();" \
"functions"

# Sequence Tests
run_test "Sequence - Basic Creation" \
"CREATE SEQUENCE public.test_seq;" \
"DROP SEQUENCE IF EXISTS public.test_seq;" \
"sequences"

run_test "Sequence - Properties Change" \
"CREATE SEQUENCE public.test_seq;
ALTER SEQUENCE public.test_seq INCREMENT BY 2 MINVALUE 0 MAXVALUE 100 RESTART WITH 10 CYCLE;" \
"DROP SEQUENCE IF EXISTS public.test_seq;" \
"sequences"

run_test "Sequence - Ownership Change" \
"CREATE SEQUENCE public.test_seq;
CREATE TABLE public.test_table (id int);
ALTER SEQUENCE public.test_seq OWNED BY public.test_table.id;" \
"DROP TABLE IF EXISTS public.test_table CASCADE; DROP SEQUENCE IF EXISTS public.test_seq;" \
"sequences"

# Additional View Tests
run_test "View - Materialized View Creation" \
"CREATE MATERIALIZED VIEW public.test_matview AS SELECT 1 as num;" \
"DROP MATERIALIZED VIEW IF EXISTS public.test_matview;" \
"views"

run_test "View - Permission Changes" \
"CREATE VIEW public.test_view AS SELECT 1 as num;
GRANT SELECT ON public.test_view TO authenticated;
REVOKE SELECT ON public.test_view FROM authenticated;" \
"DROP VIEW IF EXISTS public.test_view;" \
"views"

# Additional RLS Tests
run_test "RLS Policy - Permissive to Restrictive" \
"CREATE POLICY test_policy ON public.tools AS PERMISSIVE FOR SELECT USING (true);
DROP POLICY test_policy ON public.tools;
CREATE POLICY test_policy ON public.tools AS RESTRICTIVE FOR SELECT USING (true);" \
"DROP POLICY IF EXISTS test_policy ON public.tools;" \
"rls"

run_test "RLS Policy - With Check Changes" \
"CREATE POLICY test_policy ON public.tools FOR INSERT WITH CHECK (true);
ALTER POLICY test_policy ON public.tools WITH CHECK (false);" \
"DROP POLICY IF EXISTS test_policy ON public.tools;" \
"rls"

# Additional Table Tests
run_test "Table - Foreign Key Addition" \
"CREATE TABLE public.test_parent (id int PRIMARY KEY);
CREATE TABLE public.test_child (parent_id int);
ALTER TABLE public.test_child ADD CONSTRAINT fk_parent
    FOREIGN KEY (parent_id) REFERENCES public.test_parent(id);" \
"DROP TABLE IF EXISTS public.test_child, public.test_parent CASCADE;" \
"tables"

run_test "Table - Unique Constraint" \
"CREATE TABLE public.test_table (id int, code text);
ALTER TABLE public.test_table ADD CONSTRAINT test_unique UNIQUE (code);" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Not Null Changes" \
"CREATE TABLE public.test_table (id int NULL);
ALTER TABLE public.test_table ALTER COLUMN id SET NOT NULL;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Multiple Constraints" \
"CREATE TABLE public.test_table (
    id int,
    code text,
    value int
);
ALTER TABLE public.test_table
    ADD PRIMARY KEY (id),
    ADD UNIQUE (code),
    ADD CHECK (value > 0),
    ALTER COLUMN code SET NOT NULL;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

run_test "Table - Identity Column Changes" \
"CREATE TABLE public.test_table (id int GENERATED ALWAYS AS IDENTITY);
ALTER TABLE public.test_table ALTER COLUMN id SET GENERATED BY DEFAULT;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

# Storage Parameter Changes
run_test "Table - Storage Parameter Changes" \
"CREATE TABLE public.test_table (id int);
ALTER TABLE public.test_table SET (fillfactor = 70);" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

# Inheritance Tests
run_test "Table - Inheritance Changes" \
"CREATE TABLE public.test_parent (id int);
CREATE TABLE public.test_child () INHERITS (public.test_parent);
ALTER TABLE public.test_child NO INHERIT public.test_parent;" \
"DROP TABLE IF EXISTS public.test_child, public.test_parent;" \
"tables"

# Column Statistics
run_test "Table - Column Statistics" \
"CREATE TABLE public.test_table (id int);
ALTER TABLE public.test_table ALTER COLUMN id SET STATISTICS 100;" \
"DROP TABLE IF EXISTS public.test_table;" \
"tables"

# Print summary
echo -e "${BLUE}=== Test Summary ===${NC}"
echo -e "${GREEN}Tests passed: $TESTS_PASSED${NC}"
echo -e "${RED}Tests failed: $TESTS_FAILED${NC}"

# Exit with appropriate status
[ $TESTS_FAILED -eq 0 ]

================
File: hooks/useTemplateState.ts
================
import { useState, useEffect } from 'react';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { loadTemplates } from '../utils/loadTemplates.js';
import { TemplateStatus } from '../types.js';
import path from 'path';

export function useTemplateState() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<TemplateStatus[]>([]);

  useEffect(() => {
    async function fetchStatus() {
      try {
        const dirname = process.cwd();
        const templates = await loadTemplates(dirname);
        const buildLog = await loadBuildLog(dirname, 'common');
        const localBuildLog = await loadBuildLog(dirname, 'local');

        const combined: TemplateStatus[] = templates.map(t => ({
          name: t.name,
          path: path.relative(dirname, t.path),
          currentHash: t.currentHash,
          migrationHash: t.migrationHash,
          buildState: {
            ...buildLog.templates[path.relative(dirname, t.path)],
            ...localBuildLog.templates[path.relative(dirname, t.path)],
          },
        }));

        setItems(combined);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  return { loading, error, items };
}

================
File: lib/buildTemplates.ts
================
import glob from 'glob';
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { isWipTemplate } from '../utils/isWipTemplate.js';
import { saveBuildLog } from '../utils/saveBuildLog.js';
import { getNextTimestamp } from '../utils/getNextTimestamp.js';
import { BuildLog, CLIArgs, CLIResult, MigrationError } from '../types.js';
import { applyMigration } from '../utils/applyMigration.js';
import { calculateMD5 } from '../utils/calculateMD5.js';
import { getConfig } from '../utils/config.js';

async function findTemplates(baseDir: string, filter: string): Promise<string[]> {
  return new Promise((resolve, reject) => {
    glob(path.join(baseDir, filter), (err, matches) => {
      if (err) reject(err);
      else resolve(matches);
    });
  });
}

async function applyTemplate(
  templatePath: string,
  content: string,
  currentHash: string,
  baseDir: string,
  localBuildLog: BuildLog
): Promise<{ error?: MigrationError }> {
  const templateName = path.basename(templatePath, '.sql');
  const relativeTemplatePath = path.relative(baseDir, templatePath);

  const result = await applyMigration(content, templateName);
  if (result !== true) {
    if (!localBuildLog.templates[relativeTemplatePath]) {
      localBuildLog.templates[relativeTemplatePath] = {};
    }
    localBuildLog.templates[relativeTemplatePath].lastAppliedError = result.error;
    return { error: result };
  }

  if (!localBuildLog.templates[relativeTemplatePath]) {
    localBuildLog.templates[relativeTemplatePath] = {};
  }
  localBuildLog.templates[relativeTemplatePath].lastAppliedHash = currentHash;
  localBuildLog.templates[relativeTemplatePath].lastAppliedDate = new Date().toISOString();
  localBuildLog.templates[relativeTemplatePath].lastAppliedError = undefined;

  return {};
}

export async function buildTemplates(args: CLIArgs = {}): Promise<CLIResult> {
  const config = await getConfig();
  const baseDir = args.baseDir || process.cwd();
  const filter = args.filter || '**/*.sql';
  const errors: MigrationError[] = [];
  const applied: string[] = [];
  const verbose = args.verbose || true;
  const apply = args.apply || false;

  const buildLog = await loadBuildLog(baseDir, 'common');
  const localBuildLog = await loadBuildLog(baseDir, 'local');

  const templatePaths = await findTemplates(path.join(baseDir, config.templateDir), filter);

  if (verbose) {
    console.log(`  üìÅ Found ${chalk.yellow(templatePaths.length)} template(s)`);
  }

  for (const templatePath of templatePaths) {
    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const templateName = path.basename(templatePath, '.sql');
    const relativeTemplatePath = path.relative(baseDir, templatePath);
    const wipTemplate = await isWipTemplate(templatePath);

    if (verbose) {
      console.log(
        `  üî® ${chalk.bold('Processing')}: ${chalk.cyan(templateName)}${
          wipTemplate ? chalk.yellow(' [WIP]') : ''
        }`
      );
    }

    // Apply to database if requested
    if (apply && !wipTemplate) {
      const result = await applyTemplate(
        templatePath,
        content,
        currentHash,
        baseDir,
        localBuildLog
      );
      if (result.error) {
        errors.push(result.error);
      } else {
        applied.push(templateName);
      }
      await saveBuildLog(baseDir, localBuildLog, 'local');
    }

    // Skip file generation if requested, WIP, or unchanged
    if (args.skipFiles || wipTemplate) {
      continue;
    }

    // Skip if unchanged since last build
    const loggedTemplate = buildLog.templates[relativeTemplatePath];
    if (!args.force && loggedTemplate?.lastBuildHash === currentHash) {
      if (verbose) {
        console.log(`  ‚è≠Ô∏è  ${chalk.dim(`Unchanged since last build: ${templateName}`)}`);
      }
      continue;
    }

    // Generate migration file
    const timestamp = await getNextTimestamp(buildLog);
    const migrationName = `${timestamp}_tmpl-${templateName}.sql`;
    const migrationPath = path.join(config.migrationDir, migrationName);

    const header = `-- Generated from template: ${config.templateDir}/${templateName}.sql\n`;
    const banner = config.banner ? `-- ${config.banner}\n` : '\n';
    const footer = `${config.footer}\n-- Last built: ${buildLog.templates[relativeTemplatePath]?.lastBuildDate || 'Never'}`;
    const safeContent = config.wrapInTransaction ? `BEGIN;\n${content}\nCOMMIT;` : content;
    const migrationContent = `${header}${banner}\n${safeContent}\n${footer}`;

    await fs.writeFile(path.resolve(baseDir, migrationPath), migrationContent);

    // Update build log
    buildLog.templates[relativeTemplatePath] = {
      ...buildLog.templates[relativeTemplatePath],
      lastBuildHash: currentHash,
      lastBuildDate: new Date().toISOString(),
      lastMigrationFile: migrationName,
      lastBuildError: undefined,
    };

    if (verbose) {
      console.log(`  ‚úÖ  Generated: ${chalk.green(migrationName)}`);
    }
  }

  await saveBuildLog(baseDir, buildLog, 'common');
  await saveBuildLog(baseDir, localBuildLog, 'local');

  if (verbose) {
    if (applied.length) {
      console.log(`  üì¶ Applied ${chalk.cyan(applied.length)} migration(s)`);
    } else if (apply) {
      console.log(`  üí§ No changes to apply`);
    }
    if (errors.length) {
      console.log(`\n  ‚ùå ${chalk.red('Errors:')} ${errors.length} migration(s) failed\n`);
    }
  }

  return { errors, applied };
}

================
File: utils/applyMigration.ts
================
import chalk from 'chalk';
import { MigrationError } from '../types.js';
import { connect } from './db.connection.js';

export async function applyMigration(
  content: string,
  templateName: string
): Promise<true | MigrationError> {
  const client = await connect();
  try {
    await client.query('BEGIN');

    // Create advisory lock
    const lockKey = Math.abs(Buffer.from(templateName).reduce((acc, byte) => acc + byte, 0));
    await client.query(`SELECT pg_advisory_xact_lock(${lockKey}::bigint)`);

    await client.query(content);

    await client.query('COMMIT');

    console.log(`  ‚úÖ ${chalk.green('Applied successfully')}`);
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    console.log(`  ‚ùå ${chalk.red('Failed to apply:')} ${error}`);
    return {
      file: templateName,
      error: error as string,
      templateName,
    };
  } finally {
    client.release();
  }
}

================
File: utils/applyPendingTemplates.ts
================
import { loadTemplates } from './loadTemplates.js';
import { shouldApplyTemplate } from './templateState.js';
import { buildTemplates } from '../lib/buildTemplates.js';

import chalk from 'chalk';

export async function applyPendingTemplates(baseDir: string, filter?: string) {
  // Always load with original filter first
  const templates = await loadTemplates(baseDir, filter);
  const pendingTemplates = await Promise.all(
    templates.map(async t => ({
      template: t,
      shouldApply: await shouldApplyTemplate(t),
    }))
  );

  const templatesNeedingApply = pendingTemplates.filter(t => t.shouldApply);

  if (!templatesNeedingApply.length) {
    console.log(chalk.dim('  üí§ No changes to apply'));
    return { errors: [], applied: [] };
  }

  return buildTemplates({
    baseDir,
    // filter: path.basename(template.path),
    apply: true,
    skipFiles: true,
    verbose: true,
  });
}

================
File: utils/calculateMD5.ts
================
import crypto from 'crypto';

export async function calculateMD5(content: string): Promise<string> {
  return crypto.createHash('md5').update(content).digest('hex');
}

================
File: utils/config.ts
================
import { CLIConfig } from '../types.js';
import path from 'path';
import fs from 'fs/promises';
import { CONFIG_FILE } from '../constants.js';

let config: CLIConfig;

export async function getConfig(baseDir: string): Promise<CLIConfig> {
  if (!config) {
    config = await getConfig(baseDir);
  }
  return config;
}

const defaultConfig: CLIConfig = {
  wipIndicator: '.wip',
  filter: '**/*.sql',
  banner: 'You very likely **DO NOT** want to manually edit this generated file.',
  footer: '',
  wrapInTransaction: true,
  templateDir: 'supabase/migrations-templates',
  migrationDir: 'supabase/migrations',
  buildLog: 'supabase/migrations-templates/.buildlog.json',
  localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
  pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
};

export async function getConfig(dir?: string): Promise<CLIConfig> {
  const baseDir = dir || process.cwd();
  const configPath = path.join(baseDir, CONFIG_FILE);
  try {
    const content = await fs.readFile(configPath, 'utf-8');
    const userConfig = JSON.parse(content);
    return { ...defaultConfig, ...userConfig };
  } catch {
    return defaultConfig;
  }
}

export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
  const configPath = path.join(baseDir, CONFIG_FILE);
  const finalConfig = { ...defaultConfig, ...config };
  await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
}

================
File: utils/createEmptyBuildLog.ts
================
import { BuildLog } from '../types.js';
import { safeCreate } from './safeCreate.js';

export async function createEmptyBuildLog(filepath: string): Promise<boolean> {
  const initial = {
    version: '1.0',
    lastTimestamp: '',
    templates: {},
  } satisfies BuildLog;
  return safeCreate(filepath, JSON.stringify(initial, null, 2));
}

================
File: utils/db.connection.ts
================
import chalk from 'chalk';
import pg from 'pg';
import { getConfig } from './config.js';
const { Pool } = pg;

let pool: pg.Pool | undefined;

async function setup() {
  const config = await getConfig(process.cwd());
  if (!pool) {
    pool = new Pool({ connectionString: config.pgConnection });
  }
}

export async function connect() {
  await setup();
  if (!pool) {
    throw new Error('Failed to connect to database');
  }
  const client = await pool.connect().catch(error => {
    console.error(`  ‚ùå ${chalk.red('Failed to connect to database')}`);
    console.error(error);
    process.exit(1);
  });
  return client;
}

// Cleanup on process exit
process.on('exit', () => {
  if (pool) {
    pool.end();
  }
});

================
File: utils/displayErrorSummary.ts
================
import chalk from 'chalk';
import { MigrationError } from '../types.js';

export function displayErrorSummary(errors: MigrationError[]): void {
  if (errors.length === 0) return;

  console.log('\n  ‚ùå Error Summary:');
  console.log('  ================');
  errors.forEach(({ templateName, error }) => {
    console.log(`\n  Failed migration: ${chalk.red(templateName)}`);
    console.log(`  ${error.split('\n').join('\n  ')}`);
  });
  console.log('\n  ‚ö†Ô∏è  Some migrations failed. Please check the errors above.');
}

================
File: utils/ensureDirectories.ts
================
import fs from 'fs/promises';
import path from 'path';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function ensureDirectories(
  baseDir: string
): Promise<{ templateDir: boolean; migrationDir: boolean }> {
  const config = await getConfig();
  const templatePath = path.join(baseDir, config.templateDir);
  const migrationPath = path.join(baseDir, config.migrationDir);

  const templateExists = await fileExists(templatePath);
  const migrationExists = await fileExists(migrationPath);

  if (!templateExists) {
    await fs.mkdir(templatePath, { recursive: true });
  }

  if (!migrationExists) {
    await fs.mkdir(migrationPath, { recursive: true });
  }

  return {
    templateDir: !templateExists,
    migrationDir: !migrationExists,
  };
}

================
File: utils/fileExists.ts
================
import fs from 'fs/promises';

export async function fileExists(filepath: string): Promise<boolean> {
  try {
    await fs.access(filepath);
    return true;
  } catch {
    return false;
  }
}

================
File: utils/getMigrationFileHash.ts
================
import fs from 'fs/promises';
import path from 'path';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';

export async function getMigrationFileHash(
  migrationFile: string,
  baseDir: string
): Promise<string | null> {
  try {
    const config = await getConfig();
    const fullPath = path.join(baseDir, config.migrationDir, migrationFile);
    const content = await fs.readFile(fullPath, 'utf-8');
    return calculateMD5(content);
  } catch {
    return null;
  }
}

================
File: utils/getNextTimestamp.ts
================
import { BuildLog } from '../types.js';

export async function getNextTimestamp(buildLog: BuildLog): Promise<string> {
  const now = new Date();
  const timestamp = now.toISOString().replace(/\D/g, '').slice(0, 14);

  if (timestamp <= buildLog.lastTimestamp) {
    const nextTimestamp = (BigInt(buildLog.lastTimestamp) + 1n).toString();
    buildLog.lastTimestamp = nextTimestamp;
    return nextTimestamp;
  }

  buildLog.lastTimestamp = timestamp;
  return timestamp;
}

================
File: utils/getTimeAgo.ts
================
export function getTimeAgo(date: Date): string {
  const now = new Date();
  const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (seconds < 60) return 'just now';
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

================
File: utils/isWipTemplate.ts
================
import { getConfig } from './config.js';

export async function isWipTemplate(templatePath: string): Promise<boolean> {
  const config = await getConfig();
  return templatePath.includes(config.wipIndicator);
}

================
File: utils/loadBuildLog.ts
================
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function loadBuildLog(dirname: string, which: 'local' | 'common'): Promise<BuildLog> {
  try {
    const config = await getConfig();
    const useType = which === 'local' ? config.localBuildLog : config.buildLog;
    const content = await fs.readFile(path.resolve(dirname, useType), 'utf-8');
    const log = JSON.parse(content);
    return {
      version: log.version || '1.0',
      lastTimestamp: log.lastTimestamp || '',
      templates: log.templates || {},
    };
  } catch (error) {
    return { version: '1.0', templates: {}, lastTimestamp: '' };
  }
}

================
File: utils/loadTemplates.ts
================
import fs from 'fs/promises';
import glob from 'glob';
import path from 'path';
import { getConfig } from './config.js';
import { calculateMD5 } from './calculateMD5.js';
import { getMigrationFileHash } from './getMigrationFileHash.js';
import { TemplateStatus } from '../types.js';
import { loadBuildLog } from './loadBuildLog.js';

export async function loadTemplates(
  dirname: string,
  optionalFilter?: string
): Promise<TemplateStatus[]> {
  const config = await getConfig(dirname);
  const buildLog = await loadBuildLog(dirname, 'local');
  const filter = optionalFilter || config.filter;
  const templatePath = path.join(dirname, config.templateDir, filter);

  const templates = await new Promise<string[]>((resolve, reject) => {
    glob(templatePath, (err, matches) => {
      if (err) reject(err);
      else resolve(matches);
    });
  });

  const results: TemplateStatus[] = [];

  for (const templatePath of templates) {
    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const relPath = path.join(config.templateDir, path.basename(templatePath));
    const buildState = buildLog.templates[relPath] || {};

    results.push({
      name: path.basename(templatePath, '.sql'),
      path: templatePath,
      currentHash,
      migrationHash: null,
      buildState,
    });
  }

  return results;
}

================
File: utils/registerTemplate.ts
================
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from './loadBuildLog.js';
import { saveBuildLog } from './saveBuildLog.js';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function registerTemplate(templatePath: string, baseDir: string): Promise<void> {
  const config = await getConfig(baseDir);

  // Try multiple path resolutions
  const pathsToTry = [
    templatePath, // As provided
    path.join(baseDir, config.templateDir, templatePath), // In templates dir
  ];

  let resolvedPath: string | null = null;
  for (const p of pathsToTry) {
    if (await fileExists(p)) {
      resolvedPath = p;
      break;
    }
  }

  if (!resolvedPath) {
    console.log(chalk.red('Error:'), `Template file not found. Tried:`);
    for (const p of pathsToTry) {
      console.log(chalk.dim(`  - ${p}`));
    }
    throw new Error(`Template ${templatePath} not found`);
  }

  const content = await fs.readFile(resolvedPath, 'utf-8');
  const hash = await calculateMD5(content);
  const relativePath = path.relative(baseDir, resolvedPath);
  const now = new Date().toISOString();

  // Update build log
  const buildLog = await loadBuildLog(baseDir, 'common');
  buildLog.templates[relativePath] = {
    lastBuildHash: hash,
    lastBuildDate: now,
    lastMigrationFile: ``, // Unknown, may want to allow entering this?
  };

  await saveBuildLog(baseDir, buildLog, 'common');
  console.log(chalk.green(`‚úì Registered template:`), relativePath);
}

================
File: utils/safeCreate.ts
================
import fs from 'fs/promises';
import { fileExists } from './fileExists.js';

export async function safeCreate(filepath: string, content: string): Promise<boolean> {
  if (await fileExists(filepath)) {
    return false;
  }
  await fs.writeFile(filepath, content);
  return true;
}

================
File: utils/saveBuildLog.ts
================
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function saveBuildLog(
  dirname: string,
  log: BuildLog,
  which: 'local' | 'common'
): Promise<void> {
  const config = await getConfig();
  const useLog = which === 'local' ? config.localBuildLog : config.buildLog;
  await fs.writeFile(path.resolve(dirname, useLog), JSON.stringify(log, null, 2));
}

================
File: utils/templateState.ts
================
import {
  TemplateStatus,
  TemplateStateInfo,
  BuildStatus,
  ApplyStatus,
  TemplateState,
} from '../types.js';
import { isWipTemplate } from './isWipTemplate.js';

export async function shouldApplyTemplate(template: TemplateStatus): Promise<boolean> {
  const { currentHash, buildState } = template;

  // Only hash comparison matters for apply
  return buildState.lastAppliedHash !== currentHash;
}

export async function calculateTemplateState(template: TemplateStatus): Promise<TemplateStateInfo> {
  const { currentHash, buildState, path } = template;
  const isWip = await isWipTemplate(path);

  // Determine apply status - same logic for WIP and non-WIP
  const applyStatus = buildState.lastAppliedError
    ? ApplyStatus.ERROR
    : !buildState.lastAppliedHash
      ? ApplyStatus.NOT_APPLIED
      : buildState.lastAppliedHash === currentHash
        ? ApplyStatus.APPLIED
        : ApplyStatus.PENDING;

  // Build status - WIP templates are never built
  const buildStatus = isWip
    ? BuildStatus.NOT_BUILT
    : buildState.lastBuildError
      ? BuildStatus.ERROR
      : !buildState.lastBuildHash
        ? BuildStatus.NOT_BUILT
        : buildState.lastBuildHash === currentHash
          ? BuildStatus.BUILT
          : BuildStatus.MODIFIED;

  // Messages
  const buildMessage =
    buildState.lastBuildError ??
    (!isWip && buildStatus === BuildStatus.MODIFIED
      ? 'Template changed since last build'
      : undefined);

  const applyMessage =
    buildState.lastAppliedError ??
    (applyStatus === ApplyStatus.PENDING ? 'Changes not applied to database' : undefined);

  // Overall state
  const state = isWip
    ? TemplateState.WIP
    : applyStatus === ApplyStatus.APPLIED
      ? TemplateState.REGISTERED
      : buildStatus === BuildStatus.MODIFIED || applyStatus === ApplyStatus.PENDING
        ? TemplateState.MODIFIED
        : TemplateState.UNREGISTERED;

  return {
    state,
    buildStatus,
    applyStatus,
    currentHash,
    buildMessage,
    applyMessage,
  };
}

const statusColors = {
  [BuildStatus.BUILT]: 'green',
  [BuildStatus.MODIFIED]: 'yellow',
  [BuildStatus.ERROR]: 'red',
  [BuildStatus.NOT_BUILT]: 'gray',
  [ApplyStatus.APPLIED]: 'green',
  [ApplyStatus.PENDING]: 'yellow',
  [ApplyStatus.ERROR]: 'red',
  [ApplyStatus.NOT_APPLIED]: 'gray',
} as const;

const statusIcons = {
  [BuildStatus.BUILT]: '‚úì Built',
  [BuildStatus.MODIFIED]: '‚ö†Ô∏è Modified',
  [BuildStatus.ERROR]: '‚ùå Failed',
  [BuildStatus.NOT_BUILT]: '- Not Built',
  [ApplyStatus.APPLIED]: '‚úì Applied',
  [ApplyStatus.PENDING]: '‚ö†Ô∏è Pending',
  [ApplyStatus.ERROR]: '‚ùå Failed',
  [ApplyStatus.NOT_APPLIED]: '- Not Applied',
} as const;

export const getBuildStatusColor = (status: BuildStatus) => statusColors[status];
export const getApplyStatusColor = (status: ApplyStatus) => statusColors[status];
export const getBuildStatusIcon = (status: BuildStatus) => statusIcons[status];
export const getApplyStatusIcon = (status: ApplyStatus) => statusIcons[status];

================
File: cli.tsx
================
#!/usr/bin/env node
import Pastel from 'pastel';

const app = new Pastel({
  importMeta: import.meta,
});

await app.run();

================
File: constants.ts
================
export const CONFIG_FILE = '.srtdrc.json';

================
File: types.ts
================
export interface TemplateBuildState {
  // Build info
  lastBuildHash?: string;
  lastBuildDate?: string;
  lastBuildError?: string;
  lastMigrationFile?: string;

  // Apply info
  lastAppliedHash?: string;
  lastAppliedDate?: string;
  lastAppliedError?: string;
}

export interface BuildLog {
  version: string; // Format version
  lastTimestamp: string;
  templates: {
    [templatePath: string]: TemplateBuildState;
  };
}

export interface MigrationError {
  file: string;
  error: string;
  templateName: string;
}

export interface CLIConfig {
  filter: string;
  wipIndicator: string;
  wrapInTransaction: boolean;
  banner: string;
  footer: string;
  templateDir: string;
  migrationDir: string;
  buildLog: string;
  localBuildLog: string;
  pgConnection: string;
}

export interface CLIArgs {
  filter?: string;
  force?: boolean;
  apply?: boolean;
  skipFiles?: boolean;
  register?: string | string[];
  verbose?: boolean;
  baseDir?: string;
}

export interface CLIResult {
  errors: MigrationError[];
  applied: string[];
}

export interface TemplateStatus {
  name: string;
  path: string;
  currentHash: string;
  migrationHash: string | null;
  buildState: TemplateBuildState;
}

export enum TemplateState {
  WIP = 'WIP',
  UNREGISTERED = 'UNREGISTERED',
  REGISTERED = 'REGISTERED',
  MODIFIED = 'MODIFIED',
}

export enum BuildStatus {
  NOT_BUILT = 'NOT_BUILT',
  BUILT = 'BUILT',
  MODIFIED = 'MODIFIED',
  ERROR = 'ERROR',
}

export enum ApplyStatus {
  NOT_APPLIED = 'NOT_APPLIED',
  APPLIED = 'APPLIED',
  PENDING = 'PENDING',
  ERROR = 'ERROR',
}

export interface TemplateStateInfo {
  state: TemplateState;
  buildStatus: BuildStatus;
  applyStatus: ApplyStatus;
  currentHash: string;
  buildMessage?: string;
  applyMessage?: string;
}
