This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T12:08:45.582Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
commands/
  _app.tsx
  apply.tsx
  build.tsx
  index.tsx
  init.tsx
  register.tsx
  status.todo
  watch.tsx
components/
  StatusIndicator.tsx
  TemplateList.tsx
hooks/
  useTemplateState.ts
lib/
  buildTemplates.ts
  templateManager.test.ts
  templateManager.ts
utils/
  applyMigration.ts
  calculateMD5.ts
  config.ts
  createEmptyBuildLog.ts
  db.connection.ts
  displayErrorSummary.ts
  ensureDirectories.ts
  fileExists.ts
  getMigrationFileHash.ts
  getNextTimestamp.ts
  getTimeAgo.ts
  isWipTemplate.ts
  loadBuildLog.ts
  logger.ts
  registerTemplate.ts
  safeCreate.ts
  saveBuildLog.ts
cli.tsx
constants.ts
types.ts

================================================================
Repository Files
================================================================

================
File: commands/_app.tsx
================
import React from 'react';
import type { AppProps } from 'pastel';
import { Box } from 'ink';

export default function App({ Component, commandProps }: AppProps) {
  return (
    <Box flexDirection="column">
      <Component {...commandProps} />
    </Box>
  );
}

================
File: commands/apply.tsx
================
import React from 'react';
import { buildTemplates } from '../lib/buildTemplates.js';

export default function Apply() {
  React.useEffect(() => {
    async function doApply() {
      await buildTemplates({
        skipFiles: true,
        apply: true,
      });
      process.exit(0);
    }
    doApply();
  }, []);
  return null;
}

================
File: commands/build.tsx
================
// commands/build.tsx
import React from 'react';
import { TemplateManager } from '../lib/templateManager.js';

export default function Build() {
  React.useEffect(() => {
    async function doBuild() {
      const manager = await TemplateManager.create(process.cwd());
      await manager.processTemplates({ generateFiles: true });
      process.exit(0);
    }
    doBuild();
  }, []);

  return null;
}

================
File: commands/index.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { Select } from '@inkjs/ui';

// Import the "Register" component for demonstration of navigation:
import Register from './register.js';
import Apply from './apply.js';
import Build from './build.js';
// import Status from './status.js';
import Watch from './watch.js';

export default function UI() {
  const [selectedCommand, setSelectedCommand] = React.useState<string | null>(null);

  // For now, we only demonstrate navigation to "register"
  if (selectedCommand === 'register') {
    return <Register />;
  }

  if (selectedCommand === 'apply') {
    return <Apply />;
  }

  if (selectedCommand === 'build') {
    return <Build />;
  }

  // if (selectedCommand === 'status') {
  //   return <Status />;
  // }

  if (selectedCommand === 'watch') {
    return <Watch />;
  }

  const menuItems = [
    { label: 'üèóÔ∏è  build - Build Supabase migrations from templates', value: 'build' },
    { label: '‚ñ∂Ô∏è  apply - Apply migration templates directly to database', value: 'apply' },
    { label: '‚úçÔ∏è  register - Register templates as already built', value: 'register' },
    {
      label: 'üëÄ  watch - Watch templates for changes and apply directly to database',
      value: 'watch',
    },
    { label: '‚ÑπÔ∏è  status - Show migration status', value: 'status' },
  ];

  return (
    <Box flexDirection="column">
      <Text bold>srtd - Repeatable Template SQL Migration Tool</Text>
      <Text>Select a command:</Text>
      <Box marginTop={1}>
        <Select options={menuItems} onChange={value => setSelectedCommand(value)} />
      </Box>
    </Box>
  );
}

================
File: commands/init.tsx
================
import React from 'react';
import fs from 'fs/promises';
import path from 'path';
import { getConfig, saveConfig } from '../utils/config.js';
import { CONFIG_FILE } from '../constants.js';
import { createEmptyBuildLog } from '../utils/createEmptyBuildLog.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';
import { fileExists } from '../utils/fileExists.js';

export default function Init() {
  React.useEffect(() => {
    async function doInit() {
      try {
        const baseDir = process.cwd();
        const config = await getConfig(baseDir);
        const configPath = path.join(baseDir, CONFIG_FILE);

        if (await fileExists(configPath)) {
          console.log(`‚è≠Ô∏è ${CONFIG_FILE} already exists`);
        } else {
          await saveConfig(baseDir, {});
          console.log(`‚úÖ Created ${CONFIG_FILE} with default configuration`);
        }

        const dirs = await ensureDirectories(baseDir);
        if (dirs.templateDir) {
          console.log('‚úÖ Created template directory');
        } else {
          console.log('‚è≠Ô∏è Template directory already exists');
        }
        if (dirs.migrationDir) {
          console.log('‚úÖ Created migration directory');
        } else {
          console.log('‚è≠Ô∏è Migration directory already exists');
        }

        const buildLogCreated = await createEmptyBuildLog(path.join(baseDir, config.buildLog));
        const localBuildLogCreated = await createEmptyBuildLog(
          path.join(baseDir, config.localBuildLog)
        );

        if (buildLogCreated) console.log('‚úÖ Created build log');
        if (localBuildLogCreated) console.log('‚úÖ Created local build log');

        const gitignorePath = path.join(baseDir, '.gitignore');
        const ignoreEntry = config.localBuildLog;

        let content = '';
        try {
          content = await fs.readFile(gitignorePath, 'utf-8');
        } catch {
          // Ignore
        }

        if (!content.includes(ignoreEntry)) {
          content = content.trim() + '\n' + ignoreEntry + '\n';
          await fs.writeFile(gitignorePath, content);
          console.log('‚úÖ Updated .gitignore');
        } else {
          console.log('‚è≠Ô∏è .gitignore already updated');
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize:', error);
        process.exit(1);
      }
    }
    doInit();
  }, []);

  return null;
}

================
File: commands/register.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { MultiSelect } from '@inkjs/ui';
import { useTemplateState } from '../hooks/useTemplateState.js';
import { registerTemplate } from '../utils/registerTemplate.js';
import { argument } from 'pastel';
import zod from 'zod';

// Support both array of filenames as arguments and interactive selection
export const args = zod
  .array(zod.string())
  .optional()
  .describe(
    argument({
      name: 'templates',
      description: 'Template files to register (optional)',
    })
  );

type Props = {
  args: zod.infer<typeof args>;
};

export default function Register({ args: templateArgs }: Props) {
  const { error, items } = useTemplateState();
  const [selectedValues, setSelectedValues] = React.useState<string[]>([]);
  const [successMessage, setSuccessMessage] = React.useState('');
  const [errorMessage, setErrorMessage] = React.useState('');

  const handleTemplateRegistration = React.useCallback(async (templates: string[]) => {
    setSuccessMessage('');
    setErrorMessage('');

    let successCount = 0;
    let failCount = 0;

    for (const path of templates) {
      try {
        await registerTemplate(path, process.cwd());
        successCount++;
      } catch {
        failCount++;
      }
    }

    if (failCount > 0) {
      setErrorMessage(`Failed to register ${failCount} template(s).`);
    }
    if (successCount > 0) {
      setSuccessMessage(`Successfully registered ${successCount} template(s).`);
    }

    process.exit(failCount > 0 ? 1 : 0);
  }, []);

  React.useEffect(() => {
    // If templates were provided as arguments, register them directly
    if (templateArgs?.length) {
      void handleTemplateRegistration(templateArgs);
    }
  }, [handleTemplateRegistration, templateArgs]);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  // If no templates were provided as arguments, show interactive selection
  if (templateArgs?.length === 0) {
    const options = items.map(t => {
      const status = t.buildState.lastMigrationFile ? 'registered' : 'new';
      return {
        label: `${t.name} (${status})`,
        value: t.path,
      };
    });

    return (
      <Box flexDirection="column">
        <Text bold>Register Templates</Text>
        <Text>Use arrow/space to select, then press Enter to register.</Text>
        <Box marginTop={1}>
          <Text color="white">
            {selectedValues.length} / {options.length} selected
          </Text>
        </Box>
        <Box marginTop={1} marginBottom={1}>
          <MultiSelect
            options={options}
            onChange={vals => setSelectedValues(vals)}
            onSubmit={vals => void handleTemplateRegistration(vals)}
          />
        </Box>
        {!!errorMessage && <Text color="red">{errorMessage}</Text>}
        {!!successMessage && <Text color="green">{successMessage}</Text>}
      </Box>
    );
  }

  return (
    <Box flexDirection="column" marginTop={1}>
      {!!errorMessage && <Text color="red">{errorMessage}</Text>}
      {!!successMessage && <Text color="green">{successMessage}</Text>}
    </Box>
  );
}

================
File: commands/status.todo
================
import React from 'react';
import { Box, Text } from 'ink';
import path from 'path';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { getTimeAgo } from '../utils/getTimeAgo.js';
import { loadTemplates } from '../utils/loadTemplates.js';
import { TemplateStatus, TemplateStateInfo } from '../types.js';
import { calculateTemplateState } from '../utils/templateState.js';
import { StatusIndicator } from '../components/StatusIndicator.js';

interface TemplateWithState {
  template: TemplateStatus;
  state: TemplateStateInfo;
}

export default function Status() {
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [templateStates, setTemplateStates] = React.useState<TemplateWithState[]>([]);

  React.useEffect(() => {
    async function fetchStatus() {
      try {
        const dirname = process.cwd();
        const templates = await loadTemplates(dirname);
        const buildLog = await loadBuildLog(dirname, 'common');
        const localBuildLog = await loadBuildLog(dirname, 'local');

        const combined: TemplateStatus[] = templates.map(t => {
          const relPath = path.relative(dirname, t.path);
          const buildState = {
            ...buildLog.templates[relPath],
            ...localBuildLog.templates[relPath],
          };

          return {
            name: t.name,
            path: relPath,
            currentHash: t.currentHash,
            migrationHash: t.migrationHash,
            buildState,
          };
        });

        // Calculate states for all templates
        const states = await Promise.all(
          combined.map(async item => ({
            template: item,
            state: await calculateTemplateState(item),
          }))
        );
        setTemplateStates(states);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  const formatDate = (date?: string) => {
    if (!date) return 'Never';
    return getTimeAgo(new Date(date));
  };

  if (loading) return <Text>Loading status‚Ä¶</Text>;
  if (error) return <Text color="red">Error: {error}</Text>;

  return (
    <Box flexDirection="column">
      <Box marginBottom={1}>
        <Text bold>Template Status</Text>
      </Box>

      <Box marginY={1}>
        <Box width={25}>
          <Text bold>Template</Text>
        </Box>
        <Box width={15}>
          <Text bold>Build Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Apply Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Built</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Applied</Text>
        </Box>
      </Box>

      {templateStates.map(({ template, state }) => (
        <Box key={template.path} flexDirection="column">
          <Box>
            <Box width={25}>
              <Text>{template.name}</Text>
            </Box>
            <StatusIndicator state={state} />
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastBuildDate)}</Text>
            </Box>
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastAppliedDate)}</Text>
            </Box>
          </Box>
          {(state.buildMessage || state.applyMessage) && (
            <Box marginLeft={2} marginBottom={1}>
              {state.buildMessage && <Text color="red">Build: {state.buildMessage}</Text>}
              {state.applyMessage && <Text color="red">Apply: {state.applyMessage}</Text>}
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
}

================
File: commands/watch.tsx
================
import React from 'react';
import { Box, Text, Static } from 'ink';
import * as chokidar from 'chokidar';
import path from 'path';
import { getConfig } from '../utils/config.js';
import { TemplateManager } from '../lib/templateManager.js';
import { CLIConfig } from '../types.js';

interface FileStatus {
  filename: string;
  status: 'success' | 'error';
  templateName: string;
  timestamp: Date;
}

export default function Watch() {
  const [recentFiles, setRecentFiles] = React.useState<FileStatus[]>([]);
  const [status, setStatus] = React.useState<string>('Watching...');

  const updateFileStatus = React.useCallback(
    (filename: string, templateName: string, isSuccess: boolean) => {
      const newStatus: FileStatus = {
        filename,
        status: isSuccess ? 'success' : 'error',
        templateName,
        timestamp: new Date(),
      };

      setRecentFiles(prev => {
        const filtered = prev.filter(f => f.filename !== filename);
        return [...filtered, newStatus].slice(-10);
      });
    },
    []
  );

  React.useEffect(() => {
    let watcher: chokidar.FSWatcher;
    let manager: TemplateManager;
    let baseDir: string;
    let config: CLIConfig;

    async function processChanges(files: string[]) {
      try {
        if (!config) config = await getConfig(baseDir);
        if (!manager) manager = await TemplateManager.create(baseDir);

        const sqlFiles = files
          .filter(file => path.extname(file) === '.sql')
          .map(file => path.relative(path.join(baseDir, config.templateDir), file));

        if (sqlFiles.length > 0) {
          const result = await manager.processTemplates({
            apply: true,
            filter: sqlFiles[0],
          });

          const filename = path.basename(files[0]);
          const templateName = result.applied[0] || 'unknown';
          updateFileStatus(filename, templateName, result.applied.length > 0);
        }
      } catch {
        const filename = path.basename(files[0]);
        updateFileStatus(filename, 'error', false);
      }
    }

    async function initWatch() {
      try {
        baseDir = process.cwd();
        config = await getConfig(baseDir);
        manager = await TemplateManager.create(baseDir);
        const templatePath = path.join(baseDir, config.templateDir);

        watcher = chokidar.watch(templatePath, {
          ignored: /(^|[\/\\])\../,
          persistent: true,
          ignoreInitial: true,
          depth: 0,
        });

        watcher.on('change', (filePath: string) => {
          if (path.extname(filePath) === '.sql') {
            processChanges([filePath]);
          }
        });

        process.on('SIGINT', () => {
          watcher.close();
          process.exit(0);
        });
      } catch (error) {
        setStatus(`Watch failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    initWatch();

    return () => {
      if (watcher) watcher.close();
      process.removeAllListeners('SIGINT');
    };
  }, [updateFileStatus]);

  return (
    <Box flexDirection="column">
      <Static items={recentFiles}>
        {file => (
          <Text
            key={file.filename + file.timestamp.toISOString()}
            color={file.status === 'success' ? 'green' : 'red'}
          >
            {file.status === 'success' ? '‚úì' : '‚úó'} {file.filename} ({file.templateName}) just now
          </Text>
        )}
      </Static>
      <Text bold>{status}</Text>
    </Box>
  );
}

================
File: components/StatusIndicator.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { TemplateStateInfo } from '../types.js';
import {
  getBuildStatusColor,
  getApplyStatusColor,
  getApplyStatusIcon,
  getBuildStatusIcon,
} from '../utils/templateState.js';

interface StatusIndicatorProps {
  state: TemplateStateInfo;
}

export function StatusIndicator({ state }: StatusIndicatorProps) {
  // Move existing getStatusIndicator here
  return (
    <Box>
      <Box width={15}>
        <Text color={getBuildStatusColor(state.buildStatus)}>
          {getBuildStatusIcon(state.buildStatus)}
        </Text>
      </Box>
      <Box width={15}>
        <Text color={getApplyStatusColor(state.applyStatus)}>
          {getApplyStatusIcon(state.applyStatus)}
        </Text>
      </Box>
    </Box>
  );
}

================
File: components/TemplateList.tsx
================
import React, { useEffect, useState } from 'react';
import { Box, Text } from 'ink';
import { TemplateStatus, TemplateStateInfo } from '../types.js';
import { StatusIndicator } from './StatusIndicator.js';
import { calculateTemplateState } from '../utils/templateState.js';
import { getTimeAgo } from '../utils/getTimeAgo.js';

interface TemplateListProps {
  items: TemplateStatus[];
}

interface TemplateWithState {
  template: TemplateStatus;
  state: TemplateStateInfo;
}

export function TemplateList({ items }: TemplateListProps) {
  const [templateStates, setTemplateStates] = useState<TemplateWithState[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadStates = async () => {
      const states = await Promise.all(
        items.map(async item => ({
          template: item,
          state: await calculateTemplateState(item),
        }))
      );
      setTemplateStates(states);
      setIsLoading(false);
    };
    loadStates();
  }, [items]);

  const formatDate = (date?: string) => {
    if (!date) return 'Never';
    return getTimeAgo(new Date(date));
  };

  if (isLoading) {
    return (
      <Box>
        <Text>Loading templates...</Text>
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      {/* Header */}
      <Box marginY={1}>
        <Box width={25}>
          <Text bold>Template</Text>
        </Box>
        <Box width={15}>
          <Text bold>Build Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Apply Status</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Built</Text>
        </Box>
        <Box width={15}>
          <Text bold>Last Applied</Text>
        </Box>
      </Box>

      {/* Items */}
      {templateStates.map(({ template, state }) => (
        <Box key={template.path} flexDirection="column">
          <Box>
            <Box width={25}>
              <Text>{template.name}</Text>
            </Box>
            <StatusIndicator state={state} />
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastBuildDate)}</Text>
            </Box>
            <Box width={15}>
              <Text dimColor>{formatDate(template.buildState.lastAppliedDate)}</Text>
            </Box>
          </Box>
          {/* Error messages */}
          {(state.buildMessage || state.applyMessage) && (
            <Box marginLeft={2} marginBottom={1}>
              {state.buildMessage && <Text color="red">Build: {state.buildMessage}</Text>}
              {state.applyMessage && <Text color="red">Apply: {state.applyMessage}</Text>}
            </Box>
          )}
        </Box>
      ))}
    </Box>
  );
}

================
File: hooks/useTemplateState.ts
================
// hooks/useTemplateState.ts
import { useState, useEffect } from 'react';
import { TemplateStatus } from '../types.js';
import { TemplateManager } from '../lib/templateManager.js';
import path from 'path';

export function useTemplateState() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<TemplateStatus[]>([]);

  useEffect(() => {
    async function fetchStatus() {
      try {
        const baseDir = process.cwd();
        const manager = await TemplateManager.create(baseDir);
        const templates = await manager.findTemplates();
        const statuses = await Promise.all(templates.map(t => manager.getTemplateStatus(t)));
        setItems(statuses);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  return { loading, error, items };
}

================
File: lib/buildTemplates.ts
================
import glob from 'glob';
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { isWipTemplate } from '../utils/isWipTemplate.js';
import { saveBuildLog } from '../utils/saveBuildLog.js';
import { getNextTimestamp } from '../utils/getNextTimestamp.js';
import { BuildLog, CLIArgs, CLIResult, MigrationError } from '../types.js';
import { applyMigration } from '../utils/applyMigration.js';
import { calculateMD5 } from '../utils/calculateMD5.js';
import { getConfig } from '../utils/config.js';

async function findTemplates(baseDir: string, filter: string): Promise<string[]> {
  return new Promise((resolve, reject) => {
    glob(path.join(baseDir, filter), (err, matches) => {
      if (err) reject(err);
      else resolve(matches);
    });
  });
}

async function applyTemplate(
  templatePath: string,
  content: string,
  currentHash: string,
  baseDir: string,
  localBuildLog: BuildLog
): Promise<{ error?: MigrationError }> {
  const templateName = path.basename(templatePath, '.sql');
  const relativeTemplatePath = path.relative(baseDir, templatePath);

  const result = await applyMigration(content, templateName);
  if (result !== true) {
    if (!localBuildLog.templates[relativeTemplatePath]) {
      localBuildLog.templates[relativeTemplatePath] = {};
    }
    localBuildLog.templates[relativeTemplatePath].lastAppliedError = result.error;
    return { error: result };
  }

  if (!localBuildLog.templates[relativeTemplatePath]) {
    localBuildLog.templates[relativeTemplatePath] = {};
  }
  localBuildLog.templates[relativeTemplatePath].lastAppliedHash = currentHash;
  localBuildLog.templates[relativeTemplatePath].lastAppliedDate = new Date().toISOString();
  localBuildLog.templates[relativeTemplatePath].lastAppliedError = undefined;

  return {};
}

export async function buildTemplates(args: CLIArgs = {}): Promise<CLIResult> {
  const config = await getConfig();
  const baseDir = args.baseDir || process.cwd();
  const filter = args.filter || '**/*.sql';
  const errors: MigrationError[] = [];
  const applied: string[] = [];
  const verbose = args.verbose || true;
  const apply = args.apply || false;

  const buildLog = await loadBuildLog(baseDir, 'common');
  const localBuildLog = await loadBuildLog(baseDir, 'local');

  const templatePaths = await findTemplates(path.join(baseDir, config.templateDir), filter);

  if (verbose) {
    console.log(`  üìÅ Found ${chalk.yellow(templatePaths.length)} template(s)`);
  }

  for (const templatePath of templatePaths) {
    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const templateName = path.basename(templatePath, '.sql');
    const relativeTemplatePath = path.relative(baseDir, templatePath);
    const wipTemplate = await isWipTemplate(templatePath);

    if (verbose) {
      console.log(
        `  üî® ${chalk.bold('Processing')}: ${chalk.cyan(templateName)}${
          wipTemplate ? chalk.yellow(' [WIP]') : ''
        }`
      );
    }

    // Apply to database if requested
    if (apply && !wipTemplate) {
      const result = await applyTemplate(
        templatePath,
        content,
        currentHash,
        baseDir,
        localBuildLog
      );
      if (result.error) {
        errors.push(result.error);
      } else {
        applied.push(templateName);
      }
      await saveBuildLog(baseDir, localBuildLog, 'local');
    }

    // Skip file generation if requested, WIP, or unchanged
    if (args.skipFiles || wipTemplate) {
      continue;
    }

    // Skip if unchanged since last build
    const loggedTemplate = buildLog.templates[relativeTemplatePath];
    if (!args.force && loggedTemplate?.lastBuildHash === currentHash) {
      if (verbose) {
        console.log(`  ‚è≠Ô∏è  ${chalk.dim(`Unchanged since last build: ${templateName}`)}`);
      }
      continue;
    }

    // Generate migration file
    const timestamp = await getNextTimestamp(buildLog);
    const migrationName = `${timestamp}_tmpl-${templateName}.sql`;
    const migrationPath = path.join(config.migrationDir, migrationName);

    const header = `-- Generated from template: ${config.templateDir}/${templateName}.sql\n`;
    const banner = config.banner ? `-- ${config.banner}\n` : '\n';
    const footer = `${config.footer}\n-- Last built: ${buildLog.templates[relativeTemplatePath]?.lastBuildDate || 'Never'}`;
    const safeContent = config.wrapInTransaction ? `BEGIN;\n${content}\nCOMMIT;` : content;
    const migrationContent = `${header}${banner}\n${safeContent}\n${footer}`;

    await fs.writeFile(path.resolve(baseDir, migrationPath), migrationContent);

    // Update build log
    buildLog.templates[relativeTemplatePath] = {
      ...buildLog.templates[relativeTemplatePath],
      lastBuildHash: currentHash,
      lastBuildDate: new Date().toISOString(),
      lastMigrationFile: migrationName,
      lastBuildError: undefined,
    };

    if (verbose) {
      console.log(`  ‚úÖ  Generated: ${chalk.green(migrationName)}`);
    }
  }

  await saveBuildLog(baseDir, buildLog, 'common');
  await saveBuildLog(baseDir, localBuildLog, 'local');

  if (verbose) {
    if (applied.length) {
      console.log(`  üì¶ Applied ${chalk.cyan(applied.length)} migration(s)`);
    } else if (apply) {
      console.log(`  üí§ No changes to apply`);
    }
    if (errors.length) {
      console.log(`\n  ‚ùå ${chalk.red('Errors:')} ${errors.length} migration(s) failed\n`);
    }
  }

  return { errors, applied };
}

================
File: lib/templateManager.test.ts
================
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { TemplateManager } from '../lib/templateManager.js';
import { disconnect } from '../utils/db.connection.js';
import fs from 'fs/promises';
import path from 'path';
import { connect } from '../utils/db.connection.js';

vi.mock('../utils/config', () => ({
  getConfig: vi.fn().mockResolvedValue({
    wipIndicator: '.wip',
    templateDir: 'test-templates',
    migrationDir: 'test-migrations',
    buildLog: '.buildlog-test.json',
    localBuildLog: '.buildlog-test.local.json',
    pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
  }),
}));

vi.mock('../utils/isWipTemplate', () => ({
  isWipTemplate: vi.fn().mockImplementation(path => path.includes('.wip')),
}));

describe('TemplateManager', () => {
  const timestamp = Date.now();
  const testDir = path.join(process.cwd(), `test-tmp-${timestamp}`);
  const templateDir = path.join(testDir, 'test-templates');
  const migrationDir = path.join(testDir, 'test-migrations');
  const buildLogPath = path.join(testDir, '.buildlog-test.json');
  const localBuildLogPath = path.join(testDir, '.buildlog-test.local.json');
  const testFunctionName = `test_func_${timestamp}`;

  beforeEach(async () => {
    await fs.mkdir(templateDir, { recursive: true });
    await fs.mkdir(migrationDir, { recursive: true });

    const emptyLog = { version: '1.0', templates: {}, lastTimestamp: '' };
    await fs.writeFile(buildLogPath, JSON.stringify(emptyLog));
    await fs.writeFile(localBuildLogPath, JSON.stringify(emptyLog));

    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testFunctionName}()`);
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }
  });

  afterEach(async () => {
    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testFunctionName}()`);
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
    } finally {
      client.release();
    }

    await fs.rm(testDir, { recursive: true, force: true });
    await disconnect();
    vi.clearAllMocks();
  });

  it('should create migration file when template changes', async () => {
    const template = `test-${timestamp}.sql`;
    const templatePath = path.join(templateDir, template);
    await fs.writeFile(
      templatePath,
      `CREATE FUNCTION ${testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`
    );

    const manager = await TemplateManager.create(testDir);
    const result = await manager.processTemplates({ generateFiles: true });

    expect(result.errors).toHaveLength(0);
    const migrations = await fs.readdir(migrationDir);
    const relevantMigrations = migrations.filter(m => m.includes('test-'));
    expect(relevantMigrations).toHaveLength(1);
    expect(relevantMigrations[0]).toMatch(new RegExp(`^\\d{14}_tmpl-test-${timestamp}\\.sql$`));
  });

  it('should not generate migration files for WIP templates', async () => {
    const template = `test-${timestamp}.wip.sql`;
    const templatePath = path.join(templateDir, template);
    await fs.writeFile(
      templatePath,
      `CREATE FUNCTION ${testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`
    );

    const manager = await TemplateManager.create(testDir);

    await manager.processTemplates({ generateFiles: true });
    const migrations = await fs.readdir(migrationDir);
    const relevantMigrations = migrations.filter(m => m.includes(`test-${timestamp}`));
    expect(relevantMigrations).toHaveLength(0);
  });

  it('should allow direct database apply for WIP templates', async () => {
    const template = `test-${timestamp}.wip.sql`;
    const templatePath = path.join(templateDir, template);
    await fs.writeFile(
      templatePath,
      `CREATE FUNCTION ${testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`
    );

    const manager = await TemplateManager.create(testDir);
    const result = await manager.processTemplates({ apply: true });
    expect(result.errors).toHaveLength(0);
  });
});

================
File: lib/templateManager.ts
================
import fs from 'fs/promises';
import glob from 'glob';
import path from 'path';
import { calculateMD5 } from '../utils/calculateMD5.js';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { saveBuildLog } from '../utils/saveBuildLog.js';
import { getConfig } from '../utils/config.js';
import { isWipTemplate } from '../utils/isWipTemplate.js';
import { applyMigration } from '../utils/applyMigration.js';
import { getNextTimestamp } from '../utils/getNextTimestamp.js';
import { logger } from '../utils/logger.js';
import type { BuildLog, TemplateStatus, CLIResult } from '../types.js';

export class TemplateManager {
  private baseDir: string;
  private buildLog: BuildLog;
  private localBuildLog: BuildLog;
  private config: Awaited<ReturnType<typeof getConfig>>;

  private constructor(
    baseDir: string,
    buildLog: BuildLog,
    localBuildLog: BuildLog,
    config: Awaited<ReturnType<typeof getConfig>>
  ) {
    this.baseDir = baseDir;
    this.buildLog = buildLog;
    this.localBuildLog = localBuildLog;
    this.config = config;
  }

  static async create(baseDir: string) {
    const config = await getConfig(baseDir);
    const buildLog = await loadBuildLog(baseDir, 'common');
    const localBuildLog = await loadBuildLog(baseDir, 'local');
    return new TemplateManager(baseDir, buildLog, localBuildLog, config);
  }

  async findTemplates(filter?: string): Promise<string[]> {
    const templatePath = path.join(this.baseDir, this.config.templateDir, filter || '**/*.sql');
    logger.debug(`Looking for templates in: ${templatePath}`);

    return new Promise((resolve, reject) => {
      glob(templatePath, (err, matches) => {
        if (err) {
          logger.error(`Failed to find templates: ${err.message}`);
          reject(err);
        } else {
          logger.debug(`Found ${matches.length} template(s)`);
          resolve(matches);
        }
      });
    });
  }

  async getTemplateStatus(templatePath: string): Promise<TemplateStatus> {
    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const relPath = path.relative(this.baseDir, templatePath);
    const buildState = this.localBuildLog.templates[relPath] || {};

    return {
      name: path.basename(templatePath, '.sql'),
      path: templatePath,
      currentHash,
      migrationHash: null,
      buildState,
    };
  }

  private async generateMigration(
    templatePath: string,
    content: string,
    currentHash: string
  ): Promise<void> {
    const templateName = path.basename(templatePath, '.sql');
    const timestamp = await getNextTimestamp(this.buildLog);
    const migrationName = `${timestamp}_tmpl-${templateName}.sql`;
    const migrationPath = path.join(this.config.migrationDir, migrationName);
    const relPath = path.relative(this.baseDir, templatePath);

    const header = `-- Generated from template: ${this.config.templateDir}/${templateName}.sql\n`;
    const banner = this.config.banner ? `-- ${this.config.banner}\n` : '\n';
    const footer = `${this.config.footer}\n-- Last built: ${
      this.buildLog.templates[relPath]?.lastBuildDate || 'Never'
    }`;

    const safeContent = this.config.wrapInTransaction ? `BEGIN;\n${content}\nCOMMIT;` : content;
    const migrationContent = `${header}${banner}\n${safeContent}\n${footer}`;

    await fs.writeFile(path.resolve(this.baseDir, migrationPath), migrationContent);

    this.buildLog.templates[relPath] = {
      ...this.buildLog.templates[relPath],
      lastBuildHash: currentHash,
      lastBuildDate: new Date().toISOString(),
      lastMigrationFile: migrationName,
      lastBuildError: undefined,
    };

    await this.saveBuildLogs();
    logger.success(`Generated: ${migrationName}`);
  }

  private async saveBuildLogs(): Promise<void> {
    await Promise.all([
      saveBuildLog(this.baseDir, this.buildLog, 'common'),
      saveBuildLog(this.baseDir, this.localBuildLog, 'local'),
    ]);
  }

  async applyTemplate(template: TemplateStatus): Promise<CLIResult> {
    const content = await fs.readFile(template.path, 'utf-8');
    const result = await applyMigration(content, template.name);
    const relPath = path.relative(this.baseDir, template.path);

    if (result === true) {
      this.localBuildLog.templates[relPath] = {
        ...this.localBuildLog.templates[relPath],
        lastAppliedHash: template.currentHash,
        lastAppliedDate: new Date().toISOString(),
        lastAppliedError: undefined,
      };
      await this.saveBuildLogs();
      return { errors: [], applied: [template.name] };
    }

    this.localBuildLog.templates[relPath] = {
      ...this.localBuildLog.templates[relPath],
      lastAppliedError: result.error,
    };
    await this.saveBuildLogs();
    return { errors: [result], applied: [] };
  }

  async processTemplates(options: {
    filter?: string;
    apply?: boolean;
    generateFiles?: boolean;
    force?: boolean;
  }): Promise<CLIResult> {
    const templates = await this.findTemplates(options.filter);
    const result: CLIResult = { errors: [], applied: [] };

    for (const templatePath of templates) {
      const template = await this.getTemplateStatus(templatePath);
      const isWip = await isWipTemplate(templatePath);
      const relPath = path.relative(this.baseDir, templatePath);
      const { currentHash, buildState } = template;

      if (options.apply) {
        logger.debug(`Processing template: ${template.name}, WIP: ${isWip}`);

        // Allow applying WIP templates in watch mode
        const hasChanges = buildState.lastAppliedHash !== currentHash;
        if (hasChanges) {
          logger.debug(`Attempting to apply template: ${template.name}`);
          const applyResult = await this.applyTemplate(template);
          result.errors.push(...applyResult.errors);
          result.applied.push(...applyResult.applied);
        } else {
          logger.info(`No changes for template: ${template.name}`);
        }
      }

      if (options.generateFiles && !isWip) {
        const loggedTemplate = this.buildLog.templates[relPath];
        if (options.force || loggedTemplate?.lastBuildHash !== currentHash) {
          const content = await fs.readFile(templatePath, 'utf-8');
          await this.generateMigration(templatePath, content, currentHash);
        }
      } else if (options.generateFiles) {
        logger.skip(`Skipping WIP template: ${template.name}`);
      }
    }

    return result;
  }
}

================
File: utils/applyMigration.ts
================
import { MigrationError } from '../types.js';
import { connect } from './db.connection.js';
import { logger } from './logger.js';

export async function applyMigration(
  content: string,
  templateName: string
): Promise<true | MigrationError> {
  try {
    const client = await connect();

    // Detailed logging
    logger.debug(`Attempting to apply migration: ${templateName}`);
    logger.debug(`Migration SQL content: ${content}`);

    try {
      await client.query('BEGIN');

      const lockKey = Math.abs(Buffer.from(templateName).reduce((acc, byte) => acc + byte, 0));
      await client.query(`SELECT pg_advisory_xact_lock(${lockKey}::bigint)`);

      // Log before query execution
      logger.debug('About to execute migration query');

      await client.query(content);
      await client.query('COMMIT');

      logger.success('Migration applied successfully');
      return true;
    } catch (error) {
      await client.query('ROLLBACK');

      // Detailed error logging
      logger.error(`Migration failed for ${templateName}: ${error}`);
      console.error('Full error details:', error);

      return {
        file: templateName,
        error: error instanceof Error ? error.message : String(error),
        templateName,
      };
    } finally {
      client.release();
    }
  } catch (connectionError) {
    // Logging connection errors
    logger.error(`Database connection failed: ${connectionError}`);
    console.error('Connection error details:', connectionError);

    return {
      file: templateName,
      error: connectionError instanceof Error ? connectionError.message : String(connectionError),
      templateName,
    };
  }
}

================
File: utils/calculateMD5.ts
================
import crypto from 'crypto';

export async function calculateMD5(content: string): Promise<string> {
  return crypto.createHash('md5').update(content).digest('hex');
}

================
File: utils/config.ts
================
import { CLIConfig } from '../types.js';
import path from 'path';
import fs from 'fs/promises';
import { CONFIG_FILE } from '../constants.js';

const defaultConfig: CLIConfig = {
  wipIndicator: '.wip',
  filter: '**/*.sql',
  banner: 'You very likely **DO NOT** want to manually edit this generated file.',
  footer: '',
  wrapInTransaction: true,
  templateDir: 'supabase/migrations-templates',
  migrationDir: 'supabase/migrations',
  buildLog: 'supabase/migrations-templates/.buildlog.json',
  localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
  pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
};

let cachedConfig: CLIConfig | undefined;

export async function getConfig(dir: string = process.cwd()): Promise<CLIConfig> {
  if (cachedConfig) return cachedConfig;

  try {
    const configPath = path.join(dir, CONFIG_FILE);
    const content = await fs.readFile(configPath, 'utf-8');
    cachedConfig = { ...defaultConfig, ...JSON.parse(content) };
  } catch {
    cachedConfig = defaultConfig;
  }

  return cachedConfig!;
}

export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
  const configPath = path.join(baseDir, CONFIG_FILE);
  const finalConfig = { ...defaultConfig, ...config };
  await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
  cachedConfig = finalConfig;
}

// import { CLIConfig } from '../types.js';
// import path from 'path';
// import fs from 'fs/promises';
// import { CONFIG_FILE } from '../constants.js';

// let config: CLIConfig;

// export async function getConfig(baseDir: string): Promise<CLIConfig> {
//   if (!config) {
//     config = await getConfig(baseDir);
//   }
//   return config;
// }

// const defaultConfig: CLIConfig = {
//   wipIndicator: '.wip',
//   filter: '**/*.sql',
//   banner: 'You very likely **DO NOT** want to manually edit this generated file.',
//   footer: '',
//   wrapInTransaction: true,
//   templateDir: 'supabase/migrations-templates',
//   migrationDir: 'supabase/migrations',
//   buildLog: 'supabase/migrations-templates/.buildlog.json',
//   localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
//   pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
// };

// export async function getConfig(dir?: string): Promise<CLIConfig> {
//   const baseDir = dir || process.cwd();
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   try {
//     const content = await fs.readFile(configPath, 'utf-8');
//     const userConfig = JSON.parse(content);
//     return { ...defaultConfig, ...userConfig };
//   } catch {
//     return defaultConfig;
//   }
// }

// export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   const finalConfig = { ...defaultConfig, ...config };
//   await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
// }

================
File: utils/createEmptyBuildLog.ts
================
import { BuildLog } from '../types.js';
import { safeCreate } from './safeCreate.js';

export async function createEmptyBuildLog(filepath: string): Promise<boolean> {
  const initial = {
    version: '1.0',
    lastTimestamp: '',
    templates: {},
  } satisfies BuildLog;
  return safeCreate(filepath, JSON.stringify(initial, null, 2));
}

================
File: utils/db.connection.ts
================
// utils/db.connection.ts
import pg from 'pg';
import { getConfig } from './config.js';
import { logger } from './logger.js';

let pool: pg.Pool | undefined;
let connectionAttempts = 0;
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

async function createPool(): Promise<pg.Pool> {
  const config = await getConfig(process.cwd());
  return new pg.Pool({
    connectionString: config.pgConnection,
    connectionTimeoutMillis: 5000,
  });
}

async function retryConnection(): Promise<pg.PoolClient> {
  connectionAttempts++;
  logger.debug(`Connection attempt ${connectionAttempts}`);

  try {
    if (!pool) pool = await createPool();
    return await pool.connect();
  } catch (err) {
    if (connectionAttempts < MAX_RETRIES) {
      logger.warn(`Connection failed, retrying in ${RETRY_DELAY}ms...`);
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
      return retryConnection();
    }
    throw new Error(`Database connection failed after ${MAX_RETRIES} attempts: ${err}`);
  }
}

export async function connect(): Promise<pg.PoolClient> {
  connectionAttempts = 0;
  return retryConnection();
}

export async function disconnect(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = undefined;
  }
}

process.on('exit', async () => await disconnect());

================
File: utils/displayErrorSummary.ts
================
import chalk from 'chalk';
import { MigrationError } from '../types.js';

export function displayErrorSummary(errors: MigrationError[]): void {
  if (errors.length === 0) return;

  console.log('\n  ‚ùå Error Summary:');
  console.log('  ================');
  errors.forEach(({ templateName, error }) => {
    console.log(`\n  Failed migration: ${chalk.red(templateName)}`);
    console.log(`  ${error.split('\n').join('\n  ')}`);
  });
  console.log('\n  ‚ö†Ô∏è  Some migrations failed. Please check the errors above.');
}

================
File: utils/ensureDirectories.ts
================
// utils/ensureDirectories.ts
import fs from 'fs/promises';
import path from 'path';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function ensureDirectories(
  baseDir: string
): Promise<{ templateDir: boolean; migrationDir: boolean }> {
  const config = await getConfig(baseDir);
  const templatePath = path.join(baseDir, config.templateDir);
  const migrationPath = path.join(baseDir, config.migrationDir);

  const templateExists = await fileExists(templatePath);
  const migrationExists = await fileExists(migrationPath);

  if (!templateExists) {
    await fs.mkdir(templatePath, { recursive: true });
  }

  if (!migrationExists) {
    await fs.mkdir(migrationPath, { recursive: true });
  }

  return {
    templateDir: !templateExists,
    migrationDir: !migrationExists,
  };
}

================
File: utils/fileExists.ts
================
import fs from 'fs/promises';

export async function fileExists(filepath: string): Promise<boolean> {
  try {
    await fs.access(filepath);
    return true;
  } catch {
    return false;
  }
}

================
File: utils/getMigrationFileHash.ts
================
import fs from 'fs/promises';
import path from 'path';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';

export async function getMigrationFileHash(
  migrationFile: string,
  baseDir: string
): Promise<string | null> {
  try {
    const config = await getConfig();
    const fullPath = path.join(baseDir, config.migrationDir, migrationFile);
    const content = await fs.readFile(fullPath, 'utf-8');
    return calculateMD5(content);
  } catch {
    return null;
  }
}

================
File: utils/getNextTimestamp.ts
================
import { BuildLog } from '../types.js';

export async function getNextTimestamp(buildLog: BuildLog): Promise<string> {
  const now = new Date();
  const timestamp = now.toISOString().replace(/\D/g, '').slice(0, 14);

  if (timestamp <= buildLog.lastTimestamp) {
    const nextTimestamp = (BigInt(buildLog.lastTimestamp) + 1n).toString();
    buildLog.lastTimestamp = nextTimestamp;
    return nextTimestamp;
  }

  buildLog.lastTimestamp = timestamp;
  return timestamp;
}

================
File: utils/getTimeAgo.ts
================
export function getTimeAgo(date: Date): string {
  const now = new Date();
  const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (seconds < 60) return 'just now';
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

================
File: utils/isWipTemplate.ts
================
import { getConfig } from './config.js';

export async function isWipTemplate(templatePath: string): Promise<boolean> {
  const config = await getConfig();
  return templatePath.includes(config.wipIndicator);
}

================
File: utils/loadBuildLog.ts
================
//utils/loadBuildLog.ts
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function loadBuildLog(dirname: string, which: 'local' | 'common'): Promise<BuildLog> {
  try {
    const config = await getConfig(dirname);
    const logPath = which === 'local' ? config.localBuildLog : config.buildLog;
    const content = await fs.readFile(path.resolve(dirname, logPath), 'utf-8');
    const log = JSON.parse(content);
    return {
      version: log.version || '1.0',
      lastTimestamp: log.lastTimestamp || '',
      templates: log.templates || {},
    };
  } catch {
    return { version: '1.0', templates: {}, lastTimestamp: '' };
  }
}

================
File: utils/logger.ts
================
// utils/logger.ts
import chalk from 'chalk';

export const logger = {
  info: (msg: string) => console.log(`  ${msg}`),
  success: (msg: string) => console.log(`  ‚úÖ ${chalk.green(msg)}`),
  warn: (msg: string) => console.log(`  ‚ö†Ô∏è  ${chalk.yellow(msg)}`),
  error: (msg: string) => console.log(`  ‚ùå ${chalk.red(msg)}`),
  skip: (msg: string) => console.log(`  ‚è≠Ô∏è  ${chalk.dim(msg)}`),
  debug: (msg: string) =>
    process.env['DEBUG'] &&
    process.env['DEBUG'] == 'true' &&
    console.log(`  üîç ${chalk.white(msg)}`),
};

================
File: utils/registerTemplate.ts
================
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from './loadBuildLog.js';
import { saveBuildLog } from './saveBuildLog.js';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function registerTemplate(templatePath: string, baseDir: string): Promise<void> {
  const config = await getConfig(baseDir);

  // Try multiple path resolutions
  const pathsToTry = [
    templatePath, // As provided
    path.join(baseDir, config.templateDir, templatePath), // In templates dir
  ];

  let resolvedPath: string | null = null;
  for (const p of pathsToTry) {
    if (await fileExists(p)) {
      resolvedPath = p;
      break;
    }
  }

  if (!resolvedPath) {
    console.log(chalk.red('Error:'), `Template file not found. Tried:`);
    for (const p of pathsToTry) {
      console.log(chalk.dim(`  - ${p}`));
    }
    throw new Error(`Template ${templatePath} not found`);
  }

  const content = await fs.readFile(resolvedPath, 'utf-8');
  const hash = await calculateMD5(content);
  const relativePath = path.relative(baseDir, resolvedPath);
  const now = new Date().toISOString();

  // Update build log
  const buildLog = await loadBuildLog(baseDir, 'common');
  buildLog.templates[relativePath] = {
    lastBuildHash: hash,
    lastBuildDate: now,
    lastMigrationFile: ``, // Unknown, may want to allow entering this?
  };

  await saveBuildLog(baseDir, buildLog, 'common');
  console.log(chalk.green(`‚úì Registered template:`), relativePath);
}

================
File: utils/safeCreate.ts
================
import fs from 'fs/promises';
import { fileExists } from './fileExists.js';

export async function safeCreate(filepath: string, content: string): Promise<boolean> {
  if (await fileExists(filepath)) {
    return false;
  }
  await fs.writeFile(filepath, content);
  return true;
}

================
File: utils/saveBuildLog.ts
================
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function saveBuildLog(
  dirname: string,
  log: BuildLog,
  which: 'local' | 'common'
): Promise<void> {
  const config = await getConfig();
  const useLog = which === 'local' ? config.localBuildLog : config.buildLog;
  await fs.writeFile(path.resolve(dirname, useLog), JSON.stringify(log, null, 2));
}

================
File: cli.tsx
================
#!/usr/bin/env node
import Pastel from 'pastel';

const app = new Pastel({
  importMeta: import.meta,
});

await app.run();

================
File: constants.ts
================
export const CONFIG_FILE = '.srtdrc.json';

================
File: types.ts
================
// types.ts
export interface TemplateBuildState {
  lastBuildHash?: string;
  lastBuildDate?: string;
  lastBuildError?: string;
  lastMigrationFile?: string;
  lastAppliedHash?: string;
  lastAppliedDate?: string;
  lastAppliedError?: string;
}

export interface BuildLog {
  version: string;
  lastTimestamp: string;
  templates: {
    [templatePath: string]: TemplateBuildState;
  };
}

export interface MigrationError {
  file: string;
  error: string;
  templateName: string;
}

export interface CLIConfig {
  filter: string;
  wipIndicator: string;
  wrapInTransaction: boolean;
  banner: string;
  footer: string;
  templateDir: string;
  migrationDir: string;
  buildLog: string;
  localBuildLog: string;
  pgConnection: string;
}

export interface CLIResult {
  errors: MigrationError[];
  applied: string[];
}

export interface TemplateStatus {
  name: string;
  path: string;
  currentHash: string;
  migrationHash: string | null;
  buildState: TemplateBuildState;
}
