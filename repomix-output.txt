This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-30T10:22:51.988Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
commands/
  _app.tsx
  apply.tsx
  build.tsx
  index.tsx
  init.tsx
  register.tsx
  watch.tsx
components/
  TimeSince.tsx
hooks/
  useTemplateState.ts
lib/
  templateManager.test.ts
  templateManager.ts
utils/
  applyMigration.ts
  calculateMD5.ts
  config.ts
  createEmptyBuildLog.ts
  db.connection.ts
  displayErrorSummary.ts
  ensureDirectories.ts
  fileExists.ts
  getMigrationFileHash.ts
  getNextTimestamp.ts
  getTimeAgo.ts
  isWipTemplate.ts
  loadBuildLog.ts
  logger.ts
  registerTemplate.ts
  safeCreate.ts
  saveBuildLog.ts
cli.tsx
constants.ts
types.ts

================================================================
Files
================================================================

================
File: commands/_app.tsx
================
import React from 'react';
import type { AppProps } from 'pastel';
import { Box } from 'ink';

export default function App({ Component, commandProps }: AppProps) {
  return (
    <Box flexDirection="column">
      <Component {...commandProps} />
    </Box>
  );
}

================
File: commands/apply.tsx
================
import React from 'react';
import { TemplateManager } from '../lib/templateManager.js';

export default function Apply() {
  React.useEffect(() => {
    async function doApply() {
      try {
        const manager = await TemplateManager.create(process.cwd());
        await manager.processTemplates({ apply: true });
        process.exit(0);
      } catch (err) {
        console.error('Error:', err instanceof Error ? err.message : String(err));
        process.exit(1);
      }
    }
    void doApply();
  }, []);
  return null;
}

================
File: commands/build.tsx
================
// commands/build.tsx
import React from 'react';
import { TemplateManager } from '../lib/templateManager.js';

export default function Build() {
  React.useEffect(() => {
    async function doBuild() {
      const manager = await TemplateManager.create(process.cwd());
      await manager.processTemplates({ generateFiles: true });
      process.exit(0);
    }
    doBuild();
  }, []);

  return null;
}

================
File: commands/index.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { Select } from '@inkjs/ui';
import Register from './register.js';
import Apply from './apply.js';
import Build from './build.js';
import Watch from './watch.js';

export default function UI() {
  const [selectedCommand, setSelectedCommand] = React.useState<string | null>(null);

  // For now, we only demonstrate navigation to "register"
  if (selectedCommand === 'register') {
    return <Register args={undefined} />;
  }

  if (selectedCommand === 'apply') {
    return <Apply />;
  }

  if (selectedCommand === 'build') {
    return <Build />;
  }

  if (selectedCommand === 'watch') {
    return <Watch />;
  }

  const menuItems = [
    { label: 'üèóÔ∏è  build - Build Supabase migrations from templates', value: 'build' },
    { label: '‚ñ∂Ô∏è  apply - Apply migration templates directly to database', value: 'apply' },
    { label: '‚úçÔ∏è  register - Register templates as already built', value: 'register' },
    {
      label: 'üëÄ  watch - Watch templates for changes and apply directly to database',
      value: 'watch',
    },
  ];

  return (
    <Box flexDirection="column">
      <Text bold>srtd - Repeatable Template SQL Migration Tool</Text>
      <Text>Select a command:</Text>
      <Box marginTop={1}>
        <Select options={menuItems} onChange={value => setSelectedCommand(value)} />
      </Box>
    </Box>
  );
}

================
File: commands/init.tsx
================
import React from 'react';
import fs from 'fs/promises';
import path from 'path';
import { getConfig, saveConfig } from '../utils/config.js';
import { CONFIG_FILE } from '../constants.js';
import { createEmptyBuildLog } from '../utils/createEmptyBuildLog.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';
import { fileExists } from '../utils/fileExists.js';

export default function Init() {
  React.useEffect(() => {
    async function doInit() {
      try {
        const baseDir = process.cwd();
        const config = await getConfig(baseDir);
        const configPath = path.join(baseDir, CONFIG_FILE);

        if (await fileExists(configPath)) {
          console.log(`‚è≠Ô∏è ${CONFIG_FILE} already exists`);
        } else {
          await saveConfig(baseDir, {});
          console.log(`‚úÖ Created ${CONFIG_FILE} with default configuration`);
        }

        const dirs = await ensureDirectories(baseDir);
        if (dirs.templateDir) {
          console.log('‚úÖ Created template directory');
        } else {
          console.log('‚è≠Ô∏è Template directory already exists');
        }
        if (dirs.migrationDir) {
          console.log('‚úÖ Created migration directory');
        } else {
          console.log('‚è≠Ô∏è Migration directory already exists');
        }

        const buildLogCreated = await createEmptyBuildLog(path.join(baseDir, config.buildLog));
        const localBuildLogCreated = await createEmptyBuildLog(
          path.join(baseDir, config.localBuildLog)
        );

        if (buildLogCreated) console.log('‚úÖ Created build log');
        if (localBuildLogCreated) console.log('‚úÖ Created local build log');

        const gitignorePath = path.join(baseDir, '.gitignore');
        const ignoreEntry = config.localBuildLog;

        let content = '';
        try {
          content = await fs.readFile(gitignorePath, 'utf-8');
        } catch {
          // Ignore
        }

        if (!content.includes(ignoreEntry)) {
          content = content.trim() + '\n' + ignoreEntry + '\n';
          await fs.writeFile(gitignorePath, content);
          console.log('‚úÖ Updated .gitignore');
        } else {
          console.log('‚è≠Ô∏è .gitignore already updated');
        }
      } catch (error) {
        console.error('‚ùå Failed to initialize:', error);
        process.exit(1);
      }
    }
    doInit();
  }, []);

  return null;
}

================
File: commands/register.tsx
================
import React from 'react';
import { Box, Text } from 'ink';
import { MultiSelect } from '@inkjs/ui';
import { useTemplateState } from '../hooks/useTemplateState.js';
import { registerTemplate } from '../utils/registerTemplate.js';
import { argument } from 'pastel';
import zod from 'zod';

// Support both array of filenames as arguments and interactive selection
export const args = zod
  .array(zod.string())
  .optional()
  .describe(
    argument({
      name: 'templates',
      description: 'Template files to register (optional)',
    })
  );

type Props = {
  args: zod.infer<typeof args>;
};

export default function Register({ args: templateArgs }: Props) {
  const { error, items } = useTemplateState();
  const [selectedValues, setSelectedValues] = React.useState<string[]>([]);
  const [successMessage, setSuccessMessage] = React.useState('');
  const [errorMessage, setErrorMessage] = React.useState('');

  const handleTemplateRegistration = React.useCallback(async (templates: string[]) => {
    setSuccessMessage('');
    setErrorMessage('');

    let successCount = 0;
    let failCount = 0;

    for (const path of templates) {
      try {
        await registerTemplate(path, process.cwd());
        successCount++;
      } catch {
        failCount++;
      }
    }

    if (failCount > 0) {
      setErrorMessage(`Failed to register ${failCount} template(s).`);
    }
    if (successCount > 0) {
      setSuccessMessage(`Successfully registered ${successCount} template(s).`);
    }

    process.exit(failCount > 0 ? 1 : 0);
  }, []);

  React.useEffect(() => {
    // If templates were provided as arguments, register them directly
    if (templateArgs?.length) {
      void handleTemplateRegistration(templateArgs);
    }
  }, [handleTemplateRegistration, templateArgs]);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  // If no templates were provided as arguments, show interactive selection
  if (!templateArgs?.length) {
    const options = items.map(t => {
      const status = t.buildState.lastMigrationFile ? 'registered' : 'new';
      return {
        label: `${t.name} (${status})`,
        value: t.path,
      };
    });

    return (
      <Box flexDirection="column">
        <Text bold>Register Templates</Text>
        <Text>Use arrow/space to select, then press Enter to register.</Text>
        <Box marginTop={1}>
          <Text color="white">
            {selectedValues.length} / {options.length} selected
          </Text>
        </Box>
        <Box marginTop={1} marginBottom={1}>
          <MultiSelect
            options={options}
            onChange={vals => setSelectedValues(vals)}
            onSubmit={vals => void handleTemplateRegistration(vals)}
          />
        </Box>
        {!!errorMessage && <Text color="red">{errorMessage}</Text>}
        {!!successMessage && <Text color="green">{successMessage}</Text>}
      </Box>
    );
  }

  return (
    <Box flexDirection="column" marginTop={1}>
      {!!errorMessage && <Text color="red">{errorMessage}</Text>}
      {!!successMessage && <Text color="green">{successMessage}</Text>}
    </Box>
  );
}

================
File: commands/watch.tsx
================
import React from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import path from 'path';
import { TemplateManager } from '../lib/templateManager.js';
import type { TemplateStatus } from '../types.js';
import { TimeSince } from '../components/TimeSince.js';

export default function Watch() {
  const { exit } = useApp();
  const [templates, setTemplates] = React.useState<TemplateStatus[]>([]);
  const [error, setError] = React.useState<string>();
  const managerRef = React.useRef<TemplateManager>();
  const mounted = React.useRef(true);

  useInput((input, key) => {
    if (input.toLowerCase() === 'q' || (key.ctrl && input === 'c')) {
      mounted.current = false;
      setTimeout(() => exit(), 0);
    }
  });

  React.useEffect(() => {
    let cleanup: (() => void) | undefined;
    console.clear();

    async function init(): Promise<() => void> {
      try {
        managerRef.current = await TemplateManager.create(process.cwd(), { silent: true });

        // Initial template load
        const initialTemplates = await managerRef.current.findTemplates();
        for (const templatePath of initialTemplates) {
          const status = await managerRef.current.getTemplateStatus(templatePath);
          if (mounted.current) {
            setTemplates(prev => [...prev.filter(t => t.path !== status.path), status]);
          }
        }

        // Watch and handle changes
        const watcher = await managerRef.current.watch();

        // Update UI on template changes
        const updateTemplate = async (template: TemplateStatus) => {
          if (!mounted.current) return;
          const status = await managerRef.current?.getTemplateStatus(template.path);
          if (status) {
            setTemplates(prev => [...prev.filter(t => t.path !== status.path), status]);
          }
        };

        managerRef.current.on('templateChanged', updateTemplate);
        managerRef.current.on('templateApplied', updateTemplate);
        managerRef.current.on('templateError', ({ template }) => updateTemplate(template));

        // Initial apply for any out-of-date templates
        await managerRef.current.processTemplates({ apply: true });

        return () => {
          mounted.current = false;
          watcher.close();
        };
      } catch (err) {
        if (mounted.current) {
          setError(err instanceof Error ? err.message : String(err));
        }
        return () => {
          mounted.current = false;
        };
      }
    }

    init().then(c => (cleanup = c));
    return () => cleanup?.();
  }, []);

  if (error) {
    return <Text color="red">Error: {error}</Text>;
  }

  const templatesByDir = templates.reduce(
    (acc, template) => {
      const dir = path.dirname(path.relative(process.cwd(), template.path));
      (acc[dir] = acc[dir] || []).push(template);
      return acc;
    },
    {} as Record<string, TemplateStatus[]>
  );

  const hasErrors = templates.some(t => t.buildState.lastAppliedError);

  return (
    <Box flexDirection="column" marginBottom={2} marginTop={2}>
      <Box marginBottom={1}>
        <Text bold>srtd - Watch Mode</Text>
      </Box>

      {Object.entries(templatesByDir).map(([dir, dirTemplates]) => (
        <Box key={dir} flexDirection="column" marginLeft={1}>
          <Text dimColor>{dir}</Text>
          {dirTemplates.map(template => (
            <Box key={template.path} marginLeft={2}>
              <Box width={2}>
                <Text>
                  {template.buildState.lastAppliedError
                    ? '‚ùå'
                    : template === templates[templates.length - 1]
                      ? '‚úì'
                      : ' '}
                </Text>
              </Box>
              <Box width={20}>
                <Text>{path.basename(template.path)}</Text>
              </Box>
              <Box>
                <Text dimColor>
                  applied <TimeSince date={template.buildState.lastAppliedDate} /> ago
                  {!template.buildState.lastBuildDate ||
                  template.currentHash !== template.buildState.lastBuildHash ? (
                    <> ‚Ä¢ needs build</>
                  ) : (
                    <>
                      {' '}
                      ‚Ä¢ built <TimeSince date={template.buildState.lastBuildDate} /> ago
                    </>
                  )}
                </Text>
              </Box>
            </Box>
          ))}
        </Box>
      ))}

      {hasErrors && (
        <Box flexDirection="column" marginY={1}>
          <Text bold color="red">
            Errors
          </Text>
          {templates
            .filter(t => t.buildState.lastAppliedError)
            .map(t => (
              <Box key={t.name} marginLeft={2}>
                <Text color="red">
                  ‚Ä¢ {t.name}: {t.buildState.lastAppliedError}
                </Text>
              </Box>
            ))}
        </Box>
      )}

      <Box marginY={1}>
        <Text bold backgroundColor={hasErrors ? 'red' : 'green'}>
          {hasErrors ? ' FAIL ' : ' OK '}
        </Text>
        <Text> </Text>
        <Text dimColor>Watching for template changes...</Text>
      </Box>

      <Box>
        <Text dimColor>press </Text>
        <Text>q</Text>
        <Text dimColor> or </Text>
        <Text>Ctrl+c</Text>
        <Text dimColor> to quit</Text>
      </Box>
    </Box>
  );
}

================
File: components/TimeSince.tsx
================
import React from 'react';
import { Text } from 'ink';

export const TimeSince: React.FC<{ date?: string }> = ({ date }) => {
  const [now, setNow] = React.useState(new Date());

  React.useEffect(() => {
    const timer = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);

  if (!date) return <Text>never</Text>;

  const diff = now.getTime() - new Date(date).getTime();
  const seconds = Math.floor(diff / 1000);

  if (seconds < 60) return <Text>{seconds}s</Text>;
  if (seconds < 3600) return <Text>{Math.floor(seconds / 60)}m</Text>;
  if (seconds < 86400) return <Text>{Math.floor(seconds / 3600)}h</Text>;
  return <Text>{Math.floor(seconds / 86400)}d</Text>;
};

================
File: hooks/useTemplateState.ts
================
// hooks/useTemplateState.ts
import { useState, useEffect } from 'react';
import { TemplateStatus } from '../types.js';
import { TemplateManager } from '../lib/templateManager.js';

export function useTemplateState() {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [items, setItems] = useState<TemplateStatus[]>([]);

  useEffect(() => {
    async function fetchStatus() {
      try {
        const baseDir = process.cwd();
        const manager = await TemplateManager.create(baseDir);
        const templates = await manager.findTemplates();
        const statuses = await Promise.all(templates.map(t => manager.getTemplateStatus(t)));
        setItems(statuses);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    }
    fetchStatus();
  }, []);

  return { loading, error, items };
}

================
File: lib/templateManager.test.ts
================
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { tmpdir } from 'os';
import { join, relative } from 'path';
import fs from 'fs/promises';
import { TemplateManager } from './templateManager.js';
import { connect, disconnect } from '../utils/db.connection.js';
import { ensureDirectories } from '../utils/ensureDirectories.js';

describe('TemplateManager', () => {
  const testContext = {
    timestamp: Date.now(),
    testDir: '',
    testFunctionName: '',
  };

  beforeEach(async () => {
    testContext.testDir = join(tmpdir(), `srtd-test-${testContext.timestamp}`);
    testContext.testFunctionName = `test_func_${testContext.timestamp}`;

    await ensureDirectories(testContext.testDir);

    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testContext.testFunctionName}()`);
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }
  });

  afterEach(async () => {
    const client = await connect();
    try {
      await client.query('BEGIN');
      await client.query(`DROP FUNCTION IF EXISTS ${testContext.testFunctionName}()`);
      await client.query('COMMIT');
    } catch (_) {
      await client.query('ROLLBACK');
    } finally {
      client.release();
    }
    await fs.rm(testContext.testDir, { recursive: true, force: true });
    disconnect();
  });

  const createTemplate = async (name: string, content: string) => {
    const path = join(testContext.testDir, 'test-templates', name);
    await fs.writeFile(path, content);
    return path;
  };

  const createTemplateWithFunc = async (name: string, funcSuffix = '') => {
    const funcName = `${testContext.testFunctionName}${funcSuffix}`;
    const content = `CREATE FUNCTION ${funcName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;
    return createTemplate(name, content);
  };

  it('should create migration file when template changes', async () => {
    await createTemplateWithFunc(`test-${testContext.timestamp}.sql`);

    const manager = await TemplateManager.create(testContext.testDir);
    await manager.processTemplates({ generateFiles: true });

    const migrations = await fs.readdir(join(testContext.testDir, 'test-migrations'));
    const relevantMigrations = migrations.filter(m => m.includes(`test-${testContext.timestamp}`));
    expect(relevantMigrations).toHaveLength(1);
  });

  it('should not allow building WIP templates', async () => {
    await createTemplateWithFunc(`test-${testContext.timestamp}.wip.sql`);

    const manager = await TemplateManager.create(testContext.testDir);
    await manager.processTemplates({ generateFiles: true });

    const migrations = await fs.readdir(join(testContext.testDir, 'test-migrations'));
    expect(migrations.filter(m => m.includes(`test-${testContext.timestamp}`))).toHaveLength(0);
  });

  it('should maintain separate build and local logs', async () => {
    const templatePath = join(
      testContext.testDir,
      'test-templates',
      `test-${testContext.timestamp}.sql`
    );
    const templateContent = `CREATE FUNCTION ${testContext.testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;
    await fs.writeFile(templatePath, templateContent);

    const manager = await TemplateManager.create(testContext.testDir);

    // Build writes to build log
    await manager.processTemplates({ generateFiles: true });
    const buildLog = JSON.parse(
      await fs.readFile(join(testContext.testDir, '.buildlog-test.json'), 'utf-8')
    );
    const relPath = relative(testContext.testDir, templatePath);
    expect(buildLog.templates[relPath].lastBuildHash).toBeDefined();

    // Apply writes to local log
    await manager.processTemplates({ apply: true });
    const localLog = JSON.parse(
      await fs.readFile(join(testContext.testDir, '.buildlog-test.local.json'), 'utf-8')
    );
    expect(localLog.templates[relPath].lastAppliedHash).toBeDefined();
  });

  it('should track template state correctly', async () => {
    const templatePath = join(
      testContext.testDir,
      'test-templates',
      `test-${testContext.timestamp}.sql`
    );
    const templateContent = `CREATE FUNCTION ${testContext.testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;
    await fs.writeFile(templatePath, templateContent);

    const manager = await TemplateManager.create(testContext.testDir);

    // Initially no state
    let status = await manager.getTemplateStatus(templatePath);
    expect(status.buildState.lastBuildHash).toBeUndefined();
    expect(status.buildState.lastAppliedHash).toBeUndefined();

    // After build
    await manager.processTemplates({ generateFiles: true });
    status = await manager.getTemplateStatus(templatePath);
    expect(status.buildState.lastBuildHash).toBeDefined();
    expect(status.buildState.lastBuildDate).toBeDefined();

    // After apply
    await manager.processTemplates({ apply: true });
    status = await manager.getTemplateStatus(templatePath);
    expect(status.buildState.lastAppliedHash).toBeDefined();
    expect(status.buildState.lastAppliedDate).toBeDefined();
  });

  it('should handle rapid template changes', async () => {
    const templatePath = join(
      testContext.testDir,
      'test-templates',
      `test-${testContext.timestamp}.sql`
    );
    const baseContent = `CREATE FUNCTION ${testContext.testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;

    await fs.writeFile(templatePath, baseContent);

    const manager = await TemplateManager.create(testContext.testDir);
    const changes: string[] = [];

    manager.on('templateChanged', async template => {
      changes.push(template.currentHash);
    });

    const watcher = await manager.watch();
    await new Promise(resolve => setTimeout(resolve, 100));

    // Make rapid changes
    for (let i = 0; i < 5; i++) {
      await fs.writeFile(templatePath, `${baseContent}\n-- Change ${i}`);
      await new Promise(resolve => setTimeout(resolve, 50));
    }

    await new Promise(resolve => setTimeout(resolve, 500));
    watcher.close();

    expect(changes.length).toBeGreaterThanOrEqual(1);
    expect(new Set(changes).size).toBe(changes.length); // All changes should be unique
  }, 10000);

  it('should apply WIP templates directly to database', async () => {
    const templatePath = join(
      testContext.testDir,
      'test-templates',
      `test-${testContext.timestamp}.wip.sql`
    );
    const templateContent = `CREATE FUNCTION ${testContext.testFunctionName}() RETURNS void AS $$ BEGIN NULL; END; $$ LANGUAGE plpgsql;`;
    await fs.writeFile(templatePath, templateContent);

    const manager = await TemplateManager.create(testContext.testDir);

    const result = await manager.processTemplates({ apply: true });
    expect(result.errors).toHaveLength(0);

    const client = await connect();
    try {
      const res = await client.query(`SELECT COUNT(*) FROM pg_proc WHERE proname = $1`, [
        testContext.testFunctionName,
      ]);
      expect(parseInt(res.rows[0].count)).toBe(1);
    } finally {
      client.release();
    }
  });

  it('should handle sequential template operations', async () => {
    const templates = await Promise.all(
      [...Array(5)].map((_, i) =>
        createTemplateWithFunc(`test-${i}-${testContext.timestamp}.sql`, `_${i}`)
      )
    );

    const manager = await TemplateManager.create(testContext.testDir);

    // Apply templates one by one
    for (const _templatePath of templates) {
      const result = await manager.processTemplates({ apply: true });
      expect(result.errors).toHaveLength(0);
    }

    const client = await connect();
    try {
      for (let i = 0; i < 5; i++) {
        const res = await client.query(`SELECT proname FROM pg_proc WHERE proname = $1`, [
          `${testContext.testFunctionName}_${i}`,
        ]);
        expect(res.rows).toHaveLength(1);
      }
    } finally {
      client.release();
    }
  });

  it('should generate unique timestamps for multiple templates', async () => {
    const templates = await Promise.all(
      [...Array(10)].map((_, i) =>
        createTemplateWithFunc(`test-${i}-${testContext.timestamp}.sql`, `_${i}`)
      )
    );

    const manager = await TemplateManager.create(testContext.testDir);
    await manager.processTemplates({ generateFiles: true });

    const migrations = await fs.readdir(join(testContext.testDir, 'test-migrations'));
    const timestamps = migrations.map(m => m.split('_')[0]);
    const uniqueTimestamps = new Set(timestamps);

    expect(uniqueTimestamps.size).toBe(templates.length);
    expect(timestamps).toEqual([...timestamps].sort());
  });

  it('should handle mix of working and broken templates', async () => {
    await createTemplateWithFunc(`test-good-${testContext.timestamp}.sql`, '_good');
    await createTemplate(`test-bad-${testContext.timestamp}.sql`, 'INVALID SQL SYNTAX;');

    const manager = await TemplateManager.create(testContext.testDir);
    const result = await manager.processTemplates({ apply: true });

    expect(result.errors).toHaveLength(1);
    expect(result.applied).toHaveLength(1);

    const client = await connect();
    try {
      const res = await client.query(`SELECT COUNT(*) FROM pg_proc WHERE proname = $1`, [
        `${testContext.testFunctionName}_good`,
      ]);
      expect(parseInt(res.rows[0].count)).toBe(1);
    } finally {
      client.release();
    }
  });

  it('should handle database errors gracefully', async () => {
    const manager = await TemplateManager.create(testContext.testDir);
    await createTemplate(`test-error-${testContext.timestamp}.sql`, 'SELECT 1/0;'); // Division by zero error

    const result = await manager.processTemplates({ apply: true });
    expect(result.errors).toHaveLength(1);
    expect(result.errors[0]!.error).toMatch(/division by zero/i);
  });

  it('should handle file system errors', async () => {
    const errorPath = join(
      testContext.testDir,
      'test-templates',
      `test-error-${testContext.timestamp}.sql`
    );
    try {
      await createTemplate(`test-error-${testContext.timestamp}.sql`, 'SELECT 1;');
      await fs.chmod(errorPath, 0o000);

      const manager = await TemplateManager.create(testContext.testDir);
      await manager.processTemplates({ generateFiles: true });

      // Cleanup for afterEach
      await fs.chmod(errorPath, 0o644);
    } catch (error) {
      expect(error).toBeDefined();
      expect(error).toMatchObject({
        errno: -13,
        code: 'EACCES',
        syscall: 'open',
        path: expect.stringContaining('test-error'),
      });
      // expect(error.length).toBeGreaterThan(0);
    }
  });

  it('should handle large batches of templates', async () => {
    // Create 50 templates
    await Promise.all(
      [...Array(50)].map((_, i) =>
        createTemplateWithFunc(`test-${i}-${testContext.timestamp}.sql`, `_${i}`)
      )
    );

    const manager = await TemplateManager.create(testContext.testDir);
    const result = await manager.processTemplates({ generateFiles: true });

    expect(result.errors).toHaveLength(0);
    const migrations = await fs.readdir(join(testContext.testDir, 'test-migrations'));
    expect(migrations.length).toBe(50);
  });

  it('should handle templates with complex SQL', async () => {
    const complexSQL = `
      CREATE OR REPLACE FUNCTION ${testContext.testFunctionName}(
        param1 integer DEFAULT 100,
        OUT result1 integer,
        OUT result2 text
      ) RETURNS record AS $$
      DECLARE
        temp_var integer;
      BEGIN
        -- Complex logic with multiple statements
        SELECT CASE
          WHEN param1 > 100 THEN param1 * 2
          ELSE param1 / 2
        END INTO temp_var;

        result1 := temp_var;
        result2 := 'Processed: ' || temp_var::text;

        -- Exception handling
        EXCEPTION WHEN OTHERS THEN
          result1 := -1;
          result2 := SQLERRM;
      END;
      $$ LANGUAGE plpgsql;
    `;
    await createTemplate(`test-complex-${testContext.timestamp}.sql`, complexSQL);

    const manager = await TemplateManager.create(testContext.testDir);
    const result = await manager.processTemplates({ apply: true });
    expect(result.errors).toHaveLength(0);

    const client = await connect();
    try {
      const res = await client.query(
        `
        SELECT proname, pronargs, prorettype::regtype::text as return_type
        FROM pg_proc
        WHERE proname = $1
      `,
        [testContext.testFunctionName]
      );
      expect(res.rows).toHaveLength(1);
      expect(res.rows[0].return_type).toBe('record');
    } finally {
      client.release();
    }
  });

  it('should maintain template state across manager instances', async () => {
    const template = await createTemplateWithFunc(`test-${testContext.timestamp}.sql`);

    // First manager instance
    const manager1 = await TemplateManager.create(testContext.testDir);
    await manager1.processTemplates({ generateFiles: true });

    // Second manager instance should see the state
    const manager2 = await TemplateManager.create(testContext.testDir);
    const status = await manager2.getTemplateStatus(template);
    expect(status.buildState.lastBuildHash).toBeDefined();
  });
});

================
File: lib/templateManager.ts
================
import fs from 'fs/promises';
import glob from 'glob';
import path from 'path';
import EventEmitter from 'events';
import { calculateMD5 } from '../utils/calculateMD5.js';
import { loadBuildLog } from '../utils/loadBuildLog.js';
import { saveBuildLog } from '../utils/saveBuildLog.js';
import { getConfig } from '../utils/config.js';
import { isWipTemplate } from '../utils/isWipTemplate.js';
import { applyMigration } from '../utils/applyMigration.js';
import { getNextTimestamp } from '../utils/getNextTimestamp.js';
import { logger } from '../utils/logger.js';
import type { BuildLog, TemplateStatus, CLIResult } from '../types.js';

interface TemplateCache {
  status: TemplateStatus;
  lastChecked: number;
}

export class TemplateManager extends EventEmitter {
  private baseDir: string;
  private buildLog: BuildLog;
  private localBuildLog: BuildLog;
  private config: Awaited<ReturnType<typeof getConfig>>;
  private templateCache: Map<string, TemplateCache> = new Map();
  private cacheTimeout = 1000;
  private silent: boolean;

  // Constructor:
  private constructor(
    baseDir: string,
    buildLog: BuildLog,
    localBuildLog: BuildLog,
    config: Awaited<ReturnType<typeof getConfig>>,
    options: { silent?: boolean } = {}
  ) {
    super();
    this.silent = options.silent ?? false;
    this.baseDir = baseDir;
    this.buildLog = buildLog;
    this.localBuildLog = localBuildLog;
    this.config = config;
  }

  static async create(baseDir: string, options: { silent?: boolean } = {}) {
    const config = await getConfig(baseDir);
    const buildLog = await loadBuildLog(baseDir, 'common');
    const localBuildLog = await loadBuildLog(baseDir, 'local');
    return new TemplateManager(baseDir, buildLog, localBuildLog, config, options);
  }

  private isCacheValid(cache: TemplateCache): boolean {
    return Date.now() - cache.lastChecked < this.cacheTimeout;
  }

  private invalidateCache(templatePath: string) {
    this.templateCache.delete(templatePath);
  }

  async findTemplates(): Promise<string[]> {
    const templatePath = path.join(this.baseDir, this.config.templateDir, this.config.filter);
    return new Promise((resolve, reject) => {
      glob(templatePath, (err, matches) => {
        if (err) reject(err);
        else resolve(matches);
      });
    });
  }

  async getTemplateStatus(templatePath: string): Promise<TemplateStatus> {
    const cached = this.templateCache.get(templatePath);
    if (cached && this.isCacheValid(cached)) {
      return cached.status;
    }

    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);
    const relPath = path.relative(this.baseDir, templatePath);

    // Merge build and apply states
    const buildState = {
      ...this.buildLog.templates[relPath],
      ...this.localBuildLog.templates[relPath],
    };

    const status = {
      name: path.basename(templatePath, '.sql'),
      path: templatePath,
      currentHash,
      migrationHash: null,
      buildState,
    };

    this.templateCache.set(templatePath, {
      status,
      lastChecked: Date.now(),
    });

    return status;
  }

  private async saveBuildLogs(): Promise<void> {
    await Promise.all([
      saveBuildLog(this.baseDir, this.buildLog, 'common'),
      saveBuildLog(this.baseDir, this.localBuildLog, 'local'),
    ]);
  }

  private async handleTemplateChange(templatePath: string): Promise<void> {
    this.invalidateCache(templatePath);
    const template = await this.getTemplateStatus(templatePath);
    this.emit('templateChanged', template);

    const result = await this.applyTemplate(templatePath);
    if (result.errors.length) {
      this.emit('templateError', {
        template,
        error: result.errors[0],
      });
    } else {
      const updatedTemplate = await this.getTemplateStatus(templatePath);
      this.emit('templateApplied', updatedTemplate);
    }
  }

  async watch(): Promise<{ close: () => void }> {
    const chokidar = await import('chokidar');
    const templatePath = path.join(this.baseDir, this.config.templateDir);

    const watcher = chokidar.watch(templatePath, {
      ignoreInitial: true,
      depth: 0,
      ignored: /(^|[\\])\../,
    });

    watcher.on('change', async (filepath: string) => {
      if (path.extname(filepath) === '.sql') {
        await this.handleTemplateChange(filepath);
      }
    });

    return watcher;
  }

  async applyTemplate(templatePath: string): Promise<CLIResult> {
    const template = await this.getTemplateStatus(templatePath);
    const content = await fs.readFile(templatePath, 'utf-8');
    const result = await applyMigration(content, template.name, this.silent);
    const relPath = path.relative(this.baseDir, templatePath);

    this.invalidateCache(templatePath);

    if (result === true) {
      this.localBuildLog.templates[relPath] = {
        ...this.localBuildLog.templates[relPath],
        lastAppliedHash: template.currentHash,
        lastAppliedDate: new Date().toISOString(),
        lastAppliedError: undefined,
      };
      await this.saveBuildLogs();
      this.emit('templateApplied', template);
      return { errors: [], applied: [template.name] };
    }

    this.localBuildLog.templates[relPath] = {
      ...this.localBuildLog.templates[relPath],
      lastAppliedError: result.error,
    };
    await this.saveBuildLogs();
    this.emit('templateError', { template, error: result });
    return { errors: [result], applied: [] };
  }

  async buildTemplate(templatePath: string, force = false): Promise<void> {
    const template = await this.getTemplateStatus(templatePath);
    const isWip = await isWipTemplate(templatePath);
    const relPath = path.relative(this.baseDir, templatePath);

    if (isWip) {
      this.log(`Skipping WIP template: ${template.name}`, 'skip');
      return;
    }

    const content = await fs.readFile(templatePath, 'utf-8');
    const currentHash = await calculateMD5(content);

    if (!force && this.buildLog.templates[relPath]?.lastBuildHash === currentHash) {
      this.log(`Skipping unchanged template: ${template.name}`, 'skip');
      return;
    }

    const timestamp = await getNextTimestamp(this.buildLog);
    const migrationName = `${timestamp}_tmpl-${template.name}.sql`;
    const migrationPath = path.join(this.config.migrationDir, migrationName);

    const header = `-- Generated from template: ${this.config.templateDir}/${template.name}.sql\n`;
    const banner = this.config.banner ? `-- ${this.config.banner}\n` : '\n';
    const footer = `${this.config.footer}\n-- Last built: ${
      this.buildLog.templates[relPath]?.lastBuildDate || 'Never'
    }`;

    const safeContent = this.config.wrapInTransaction ? `BEGIN;\n${content}\nCOMMIT;` : content;
    const migrationContent = `${header}${banner}\n${safeContent}\n${footer}`;

    await fs.writeFile(path.resolve(this.baseDir, migrationPath), migrationContent);

    this.buildLog.templates[relPath] = {
      ...this.buildLog.templates[relPath],
      lastBuildHash: currentHash,
      lastBuildDate: new Date().toISOString(),
      lastMigrationFile: migrationName,
      lastBuildError: undefined,
    };

    this.invalidateCache(templatePath);
    await this.saveBuildLogs();
    this.emit('templateBuilt', template);
  }

  private log(msg: string, type: 'info' | 'error' | 'success' | 'skip' = 'info') {
    if (this.silent) return;
    if (type === 'error') logger.error(msg);
    else if (type === 'success') logger.success(msg);
    else if (type === 'skip') logger.skip(msg);
    else logger.info(msg);
  }
  async processTemplates(options: {
    apply?: boolean;
    generateFiles?: boolean;
    force?: boolean;
  }): Promise<CLIResult> {
    const templates = await this.findTemplates();
    const result: CLIResult = { errors: [], applied: [] };

    if (options.apply) {
      this.log('Applying changes...');
      let hasChanges = false;

      for (const templatePath of templates) {
        const template = await this.getTemplateStatus(templatePath);
        const needsApply =
          !template.buildState.lastAppliedHash ||
          template.buildState.lastAppliedHash !== template.currentHash;

        if (needsApply) {
          hasChanges = true;
          const applyResult = await this.applyTemplate(templatePath);
          result.errors.push(...applyResult.errors);
          result.applied.push(...applyResult.applied);
        }
      }

      if (!hasChanges) {
        this.log('No changes to apply');
      } else if (result.errors.length > 0) {
        this.log(`${result.errors.length} template(s) failed to apply`, 'error');
        result.errors.forEach(err => this.log(`${err.file}: ${err.error}`, 'error'));
      } else {
        this.log(`Applied ${result.applied.length} template(s)`, 'success');
      }
    }

    if (options.generateFiles) {
      let built = 0;
      let skipped = 0;

      for (const templatePath of templates) {
        const isWip = await isWipTemplate(templatePath);
        if (!isWip) {
          const template = await this.getTemplateStatus(templatePath);
          if (options.force || template.currentHash !== template.buildState.lastBuildHash) {
            await this.buildTemplate(templatePath, options.force);
            built++;
          } else {
            skipped++;
          }
        }
      }

      if (built > 0) {
        this.log(`Generated ${built} migration file(s)`, 'success');
      } else if (skipped > 0) {
        this.log('No changes to build');
      }
    }

    return result;
  }
}

================
File: utils/applyMigration.ts
================
import { MigrationError } from '../types.js';
import { connect } from './db.connection.js';
import { logger } from './logger.js';

export async function applyMigration(
  content: string,
  templateName: string,
  silent: boolean = false
): Promise<true | MigrationError> {
  const client = await connect();
  try {
    await client.query('BEGIN');
    const lockKey = Math.abs(Buffer.from(templateName).reduce((acc, byte) => acc + byte, 0));
    await client.query(`SELECT pg_advisory_xact_lock(${lockKey}::bigint)`);
    await client.query(content);
    await client.query('COMMIT');
    if (!silent) logger.success('Migration applied successfully');
    return true;
  } catch (error) {
    await client.query('ROLLBACK');
    if (!silent) logger.error(`Migration failed for ${templateName}: ${error}`);
    return {
      file: templateName,
      error: error instanceof Error ? error.message : String(error),
      templateName,
    };
  } finally {
    client.release();
  }
}

================
File: utils/calculateMD5.ts
================
import crypto from 'crypto';

export async function calculateMD5(content: string): Promise<string> {
  return crypto.createHash('md5').update(content).digest('hex');
}

================
File: utils/config.ts
================
import { CLIConfig } from '../types.js';
import path from 'path';
import fs from 'fs/promises';
import { CONFIG_FILE } from '../constants.js';

const defaultConfig: CLIConfig = {
  wipIndicator: '.wip',
  filter: '**/*.sql',
  banner: 'You very likely **DO NOT** want to manually edit this generated file.',
  footer: '',
  wrapInTransaction: true,
  templateDir: 'supabase/migrations-templates',
  migrationDir: 'supabase/migrations',
  buildLog: 'supabase/migrations-templates/.buildlog.json',
  localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
  pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
};

let cachedConfig: CLIConfig | undefined;

export async function getConfig(dir: string = process.cwd()): Promise<CLIConfig> {
  if (cachedConfig) return cachedConfig;

  try {
    const configPath = path.join(dir, CONFIG_FILE);
    const content = await fs.readFile(configPath, 'utf-8');
    cachedConfig = { ...defaultConfig, ...JSON.parse(content) };
  } catch {
    cachedConfig = defaultConfig;
  }

  return cachedConfig!;
}

export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
  const configPath = path.join(baseDir, CONFIG_FILE);
  const finalConfig = { ...defaultConfig, ...config };
  await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
  cachedConfig = finalConfig;
}

// import { CLIConfig } from '../types.js';
// import path from 'path';
// import fs from 'fs/promises';
// import { CONFIG_FILE } from '../constants.js';

// let config: CLIConfig;

// export async function getConfig(baseDir: string): Promise<CLIConfig> {
//   if (!config) {
//     config = await getConfig(baseDir);
//   }
//   return config;
// }

// const defaultConfig: CLIConfig = {
//   wipIndicator: '.wip',
//   filter: '**/*.sql',
//   banner: 'You very likely **DO NOT** want to manually edit this generated file.',
//   footer: '',
//   wrapInTransaction: true,
//   templateDir: 'supabase/migrations-templates',
//   migrationDir: 'supabase/migrations',
//   buildLog: 'supabase/migrations-templates/.buildlog.json',
//   localBuildLog: 'supabase/migrations-templates/.buildlog.local.json',
//   pgConnection: 'postgresql://postgres:postgres@localhost:54322/postgres',
// };

// export async function getConfig(dir?: string): Promise<CLIConfig> {
//   const baseDir = dir || process.cwd();
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   try {
//     const content = await fs.readFile(configPath, 'utf-8');
//     const userConfig = JSON.parse(content);
//     return { ...defaultConfig, ...userConfig };
//   } catch {
//     return defaultConfig;
//   }
// }

// export async function saveConfig(baseDir: string, config: Partial<CLIConfig>): Promise<void> {
//   const configPath = path.join(baseDir, CONFIG_FILE);
//   const finalConfig = { ...defaultConfig, ...config };
//   await fs.writeFile(configPath, JSON.stringify(finalConfig, null, 2));
// }

================
File: utils/createEmptyBuildLog.ts
================
import { BuildLog } from '../types.js';
import { safeCreate } from './safeCreate.js';

export async function createEmptyBuildLog(filepath: string): Promise<boolean> {
  const initial = {
    version: '1.0',
    lastTimestamp: '',
    templates: {},
  } satisfies BuildLog;
  return safeCreate(filepath, JSON.stringify(initial, null, 2));
}

================
File: utils/db.connection.ts
================
// utils/db.connection.ts
import pg from 'pg';
import { getConfig } from './config.js';
import { logger } from './logger.js';

let pool: pg.Pool | undefined;
let connectionAttempts = 0;
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

async function createPool(): Promise<pg.Pool> {
  const config = await getConfig(process.cwd());
  return new pg.Pool({
    connectionString: config.pgConnection,
    connectionTimeoutMillis: 5000,
  });
}

async function retryConnection(): Promise<pg.PoolClient> {
  connectionAttempts++;
  logger.debug(`Connection attempt ${connectionAttempts}`);

  try {
    if (!pool) pool = await createPool();
    return await pool.connect();
  } catch (err) {
    if (connectionAttempts < MAX_RETRIES) {
      logger.warn(`Connection failed, retrying in ${RETRY_DELAY}ms...`);
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
      return retryConnection();
    }
    throw new Error(`Database connection failed after ${MAX_RETRIES} attempts: ${err}`);
  }
}

export async function connect(): Promise<pg.PoolClient> {
  connectionAttempts = 0;
  return retryConnection();
}

export async function disconnect(): Promise<void> {
  if (pool) {
    await pool.end();
    pool = undefined;
  }
}

process.on('exit', async () => await disconnect());

================
File: utils/displayErrorSummary.ts
================
import chalk from 'chalk';
import { MigrationError } from '../types.js';

export function displayErrorSummary(errors: MigrationError[]): void {
  if (errors.length === 0) return;

  console.log('\n  ‚ùå Error Summary:');
  console.log('  ================');
  errors.forEach(({ templateName, error }) => {
    console.log(`\n  Failed migration: ${chalk.red(templateName)}`);
    console.log(`  ${error.split('\n').join('\n  ')}`);
  });
  console.log('\n  ‚ö†Ô∏è  Some migrations failed. Please check the errors above.');
}

================
File: utils/ensureDirectories.ts
================
// utils/ensureDirectories.ts
import fs from 'fs/promises';
import path from 'path';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function ensureDirectories(
  baseDir: string
): Promise<{ templateDir: boolean; migrationDir: boolean }> {
  const config = await getConfig(baseDir);
  const templatePath = path.join(baseDir, config.templateDir);
  const migrationPath = path.join(baseDir, config.migrationDir);

  const templateExists = await fileExists(templatePath);
  const migrationExists = await fileExists(migrationPath);

  if (!templateExists) {
    await fs.mkdir(templatePath, { recursive: true });
  }

  if (!migrationExists) {
    await fs.mkdir(migrationPath, { recursive: true });
  }

  return {
    templateDir: !templateExists,
    migrationDir: !migrationExists,
  };
}

================
File: utils/fileExists.ts
================
import fs from 'fs/promises';

export async function fileExists(filepath: string): Promise<boolean> {
  try {
    await fs.access(filepath);
    return true;
  } catch {
    return false;
  }
}

================
File: utils/getMigrationFileHash.ts
================
import fs from 'fs/promises';
import path from 'path';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';

export async function getMigrationFileHash(
  migrationFile: string,
  baseDir: string
): Promise<string | null> {
  try {
    const config = await getConfig();
    const fullPath = path.join(baseDir, config.migrationDir, migrationFile);
    const content = await fs.readFile(fullPath, 'utf-8');
    return calculateMD5(content);
  } catch {
    return null;
  }
}

================
File: utils/getNextTimestamp.ts
================
import { BuildLog } from '../types.js';

export async function getNextTimestamp(buildLog: BuildLog): Promise<string> {
  const now = new Date();
  const timestamp = now.toISOString().replace(/\D/g, '').slice(0, 14);

  if (timestamp <= buildLog.lastTimestamp) {
    const nextTimestamp = (BigInt(buildLog.lastTimestamp) + 1n).toString();
    buildLog.lastTimestamp = nextTimestamp;
    return nextTimestamp;
  }

  buildLog.lastTimestamp = timestamp;
  return timestamp;
}

================
File: utils/getTimeAgo.ts
================
export function getTimeAgo(date: Date): string {
  const now = new Date();
  const seconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (seconds < 60) return 'just now';
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}

================
File: utils/isWipTemplate.ts
================
import { getConfig } from './config.js';

export async function isWipTemplate(templatePath: string): Promise<boolean> {
  const config = await getConfig();
  return templatePath.includes(config.wipIndicator);
}

================
File: utils/loadBuildLog.ts
================
//utils/loadBuildLog.ts
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function loadBuildLog(dirname: string, which: 'local' | 'common'): Promise<BuildLog> {
  try {
    const config = await getConfig(dirname);
    const logPath = which === 'local' ? config.localBuildLog : config.buildLog;
    const content = await fs.readFile(path.resolve(dirname, logPath), 'utf-8');
    const log = JSON.parse(content);
    return {
      version: log.version || '1.0',
      lastTimestamp: log.lastTimestamp || '',
      templates: log.templates || {},
    };
  } catch {
    return { version: '1.0', templates: {}, lastTimestamp: '' };
  }
}

================
File: utils/logger.ts
================
// utils/logger.ts
import chalk from 'chalk';

export const logger = {
  info: (msg: string) => console.log(`  ${msg}`),
  success: (msg: string) => console.log(`  ‚úÖ ${chalk.green(msg)}`),
  warn: (msg: string) => console.log(`  ‚ö†Ô∏è  ${chalk.yellow(msg)}`),
  error: (msg: string) => console.log(`  ‚ùå ${chalk.red(msg)}`),
  skip: (msg: string) => console.log(`  ‚è≠Ô∏è  ${chalk.dim(msg)}`),
  debug: (msg: string) =>
    process.env['DEBUG'] &&
    process.env['DEBUG'] == 'true' &&
    console.log(`  üîç ${chalk.white(msg)}`),
};

================
File: utils/registerTemplate.ts
================
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { loadBuildLog } from './loadBuildLog.js';
import { saveBuildLog } from './saveBuildLog.js';
import { calculateMD5 } from './calculateMD5.js';
import { getConfig } from './config.js';
import { fileExists } from './fileExists.js';

export async function registerTemplate(templatePath: string, baseDir: string): Promise<void> {
  const config = await getConfig(baseDir);

  // Try multiple path resolutions
  const pathsToTry = [
    templatePath, // As provided
    path.join(baseDir, config.templateDir, templatePath), // In templates dir
  ];

  let resolvedPath: string | null = null;
  for (const p of pathsToTry) {
    if (await fileExists(p)) {
      resolvedPath = p;
      break;
    }
  }

  if (!resolvedPath) {
    console.log(chalk.red('Error:'), `Template file not found. Tried:`);
    for (const p of pathsToTry) {
      console.log(chalk.dim(`  - ${p}`));
    }
    throw new Error(`Template ${templatePath} not found`);
  }

  const content = await fs.readFile(resolvedPath, 'utf-8');
  const hash = await calculateMD5(content);
  const relativePath = path.relative(baseDir, resolvedPath);
  const now = new Date().toISOString();

  // Update build log
  const buildLog = await loadBuildLog(baseDir, 'common');
  buildLog.templates[relativePath] = {
    lastBuildHash: hash,
    lastBuildDate: now,
    lastMigrationFile: ``, // Unknown, may want to allow entering this?
  };

  await saveBuildLog(baseDir, buildLog, 'common');
  console.log(chalk.green(`‚úì Registered template:`), relativePath);
}

================
File: utils/safeCreate.ts
================
import fs from 'fs/promises';
import { fileExists } from './fileExists.js';

export async function safeCreate(filepath: string, content: string): Promise<boolean> {
  if (await fileExists(filepath)) {
    return false;
  }
  await fs.writeFile(filepath, content);
  return true;
}

================
File: utils/saveBuildLog.ts
================
import fs from 'fs/promises';
import path from 'path';
import { BuildLog } from '../types.js';
import { getConfig } from './config.js';

export async function saveBuildLog(
  dirname: string,
  log: BuildLog,
  which: 'local' | 'common'
): Promise<void> {
  const config = await getConfig();
  const useLog = which === 'local' ? config.localBuildLog : config.buildLog;
  await fs.writeFile(path.resolve(dirname, useLog), JSON.stringify(log, null, 2));
}

================
File: cli.tsx
================
#!/usr/bin/env node
import Pastel from 'pastel';

const app = new Pastel({
  importMeta: import.meta,
});

await app.run();

================
File: constants.ts
================
export const CONFIG_FILE = '.srtdrc.json';

================
File: types.ts
================
// types.ts
export interface TemplateBuildState {
  lastBuildHash?: string;
  lastBuildDate?: string;
  lastBuildError?: string;
  lastMigrationFile?: string;
  lastAppliedHash?: string;
  lastAppliedDate?: string;
  lastAppliedError?: string;
}

export interface BuildLog {
  version: string;
  lastTimestamp: string;
  templates: {
    [templatePath: string]: TemplateBuildState;
  };
}

export interface MigrationError {
  file: string;
  error: string;
  templateName: string;
}

export interface CLIConfig {
  filter: string;
  wipIndicator: string;
  wrapInTransaction: boolean;
  banner: string;
  footer: string;
  templateDir: string;
  migrationDir: string;
  buildLog: string;
  localBuildLog: string;
  pgConnection: string;
}

export interface CLIResult {
  errors: MigrationError[];
  applied: string[];
}

export interface TemplateStatus {
  name: string;
  path: string;
  currentHash: string;
  migrationHash: string | null;
  buildState: TemplateBuildState;
}
