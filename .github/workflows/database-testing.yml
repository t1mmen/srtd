name: Database Testing with Supabase

on:
  push:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'supabase/**'
      - 'templates/**'
      - 'migrations/**'
      - '.github/workflows/database-testing.yml'
      - 'package*.json'
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**'
      - 'supabase/**'
      - 'templates/**'
      - 'migrations/**'
      - '.github/workflows/database-testing.yml'
      - 'package*.json'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test against'
        required: false
        default: 'test'
        type: choice
        options:
          - test
          - staging
          - production-like

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.run_id }}
  cancel-in-progress: false

env:
  SUPABASE_VERSION: 1.123.4  # Pin Supabase CLI version for consistency

jobs:
  # Job 1: Setup and validate workflow configuration
  setup:
    name: Setup Workflow Environment
    runs-on: ubuntu-latest
    outputs:
      test-id: ${{ steps.generate-id.outputs.test-id }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate unique test ID
        id: generate-id
        run: |
          TEST_ID="test_${GITHUB_RUN_ID}_${GITHUB_RUN_NUMBER}_$(date +%s)"
          echo "test-id=${TEST_ID}" >> $GITHUB_OUTPUT
          echo "Generated test ID: ${TEST_ID}"

      - name: Set up test matrix
        id: set-matrix
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Use manual input for environment
            MATRIX='{"environment": ["${{ github.event.inputs.environment }}"], "node": ["20.x"], "postgres": ["15"]}'
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            # Full matrix for main branch
            MATRIX='{"environment": ["test", "staging"], "node": ["20.x", "22.x"], "postgres": ["14", "15"]}'
          else
            # Reduced matrix for PRs and other branches
            MATRIX='{"environment": ["test"], "node": ["20.x"], "postgres": ["15"]}'
          fi
          echo "matrix=${MATRIX}" >> $GITHUB_OUTPUT
          echo "Test matrix: ${MATRIX}"

  # Job 2: Database testing with real Supabase instances
  database-test:
    name: DB Test (${{ matrix.environment }}/Node${{ matrix.node }}/PG${{ matrix.postgres }})
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
      fail-fast: false
    
    services:
      postgres:
        image: postgres:${{ matrix.postgres }}-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: srtd_test_${{ needs.setup.outputs.test-id }}
        ports:
          - 54323:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci
        env:
          NODE_ENV: test

      - name: Build project
        run: npm run build

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: ${{ env.SUPABASE_VERSION }}

      - name: Configure Supabase for ${{ matrix.environment }}
        run: |
          # Copy config for environment
          if [ "${{ matrix.environment }}" != "test" ]; then
            cp supabase/config.${{ matrix.environment }}.toml supabase/config.toml 2>/dev/null || true
          fi
          
          # Start Supabase local development
          supabase start --ignore-health-check

      - name: Create isolated test schema
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Create test schema with unique name
          SCHEMA_NAME="srtd_${{ needs.setup.outputs.test-id }}_${{ matrix.environment }}"
          psql "$DATABASE_URL" <<-EOSQL
            CREATE SCHEMA IF NOT EXISTS ${SCHEMA_NAME};
            SET search_path TO ${SCHEMA_NAME}, public;
            
            -- Create necessary extensions
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
            CREATE EXTENSION IF NOT EXISTS "pgcrypto";
          EOSQL
          
          echo "SRTD_TEST_SCHEMA=${SCHEMA_NAME}" >> $GITHUB_ENV

      - name: Run SRTD init
        run: |
          node dist/cli.js init
          ls -la .srtd/
          ls -la templates/

      - name: Create test templates
        run: |
          # Create sample templates for testing
          cat > templates/001_users.sql <<-'EOF'
          CREATE TABLE IF NOT EXISTS users (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            email TEXT UNIQUE NOT NULL,
            name TEXT,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          CREATE INDEX idx_users_email ON users(email);
          EOF
          
          cat > templates/002_posts.sql <<-'EOF'
          CREATE TABLE IF NOT EXISTS posts (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id UUID REFERENCES users(id) ON DELETE CASCADE,
            title TEXT NOT NULL,
            content TEXT,
            published BOOLEAN DEFAULT false,
            created_at TIMESTAMPTZ DEFAULT NOW(),
            updated_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          CREATE INDEX idx_posts_user_id ON posts(user_id);
          CREATE INDEX idx_posts_published ON posts(published);
          EOF
          
          cat > templates/003_comments.sql <<-'EOF'
          CREATE TABLE IF NOT EXISTS comments (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
            user_id UUID REFERENCES users(id) ON DELETE CASCADE,
            content TEXT NOT NULL,
            created_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          CREATE INDEX idx_comments_post_id ON comments(post_id);
          CREATE INDEX idx_comments_user_id ON comments(user_id);
          EOF

      - name: Test SRTD register command
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Register all templates
          node dist/cli.js register templates/*.sql
          
          # Verify registration in build log
          cat .srtd/build.log | jq '.'

      - name: Test SRTD apply command
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Apply templates to database
          node dist/cli.js apply --force
          
          # Verify tables were created
          psql "$DATABASE_URL" -c "\dt ${SRTD_TEST_SCHEMA}.*"

      - name: Test SRTD build command
        run: |
          # Build migrations
          node dist/cli.js build
          
          # List generated migrations
          ls -la migrations/
          
          # Verify migration content
          if ls migrations/*.sql 1> /dev/null 2>&1; then
            echo "Migrations generated successfully"
            head -n 20 migrations/*.sql
          else
            echo "No migrations generated (might be expected if no changes)"
          fi

      - name: Test SRTD watch command (background)
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Start watch mode in background
          timeout 10 node dist/cli.js watch &
          WATCH_PID=$!
          
          # Give it time to start
          sleep 3
          
          # Modify a template
          echo "-- Modified at $(date)" >> templates/001_users.sql
          
          # Wait for watch to detect change
          sleep 5
          
          # Check if watch is still running
          if ps -p $WATCH_PID > /dev/null; then
            echo "Watch mode is running"
            kill $WATCH_PID || true
          else
            echo "Watch mode exited"
          fi

      - name: Validate SQL syntax and migrations
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Validate all SQL templates syntax
          for template in templates/*.sql; do
            echo "Validating ${template}..."
            psql "$DATABASE_URL" -c "BEGIN; $(cat ${template}); ROLLBACK;"
          done
          
          # Validate migration files if they exist
          if ls migrations/*.sql 1> /dev/null 2>&1; then
            for migration in migrations/*.sql; do
              echo "Validating ${migration}..."
              psql "$DATABASE_URL" -c "BEGIN; $(cat ${migration}); ROLLBACK;"
            done
          fi

      - name: Run integration tests with real database
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
          SUPABASE_URL: http://localhost:54321
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY_TEST }}
          SRTD_TEST_MODE: integration
        run: |
          # Run integration tests specifically
          npm test -- src/services/__tests__/integration.test.ts

      - name: Test database operations and performance
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/srtd_test_${{ needs.setup.outputs.test-id }}
        run: |
          # Test connection pooling
          node -e "
          const { DatabaseService } = require('./dist/services/DatabaseService.js');
          const db = new DatabaseService({ connectionString: process.env.DATABASE_URL });
          
          async function testPooling() {
            console.time('Connection Pool Test');
            const promises = [];
            for (let i = 0; i < 20; i++) {
              promises.push(db.executeSQL('SELECT NOW()'));
            }
            await Promise.all(promises);
            console.timeEnd('Connection Pool Test');
            await db.destroy();
          }
          
          testPooling().catch(console.error);
          "

      - name: Collect database logs and metrics
        if: always()
        run: |
          # Get Supabase logs
          supabase db logs --tail 100 > supabase-db-logs.txt || true
          
          # Get test results
          if [ -f test-report.junit.xml ]; then
            cp test-report.junit.xml database-test-report-${{ matrix.environment }}-node${{ matrix.node }}-pg${{ matrix.postgres }}.xml
          fi

      - name: Cleanup test database
        if: always()
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/postgres
        run: |
          # Drop test database and schema
          psql "$DATABASE_URL" -c "DROP DATABASE IF EXISTS srtd_test_${{ needs.setup.outputs.test-id }};" || true
          
          # Stop Supabase
          supabase stop --no-backup || true

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: database-test-artifacts-${{ matrix.environment }}-node${{ matrix.node }}-pg${{ matrix.postgres }}
          path: |
            supabase-db-logs.txt
            database-test-report-*.xml
            .srtd/build.log
            .srtd/state.json
            migrations/*.sql
          retention-days: 7

  # Job 3: Performance regression testing
  performance-test:
    name: Performance Regression Testing
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: perf_test
        ports:
          - 54323:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: 'npm'

      - name: Install and build
        run: |
          npm ci
          npm run build

      - name: Run performance benchmarks
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:54323/perf_test
        run: |
          # Create performance test script
          cat > perf-test.js <<-'EOF'
          const { performance } = require('perf_hooks');
          const { DatabaseService } = require('./dist/services/DatabaseService.js');
          const { FileSystemService } = require('./dist/services/FileSystemService.js');
          const { StateService } = require('./dist/services/StateService.js');
          const { MigrationBuilder } = require('./dist/services/MigrationBuilder.js');
          const fs = require('fs').promises;
          
          async function runBenchmarks() {
            const results = {};
            
            // Test 1: Template discovery performance
            const fileService = new FileSystemService();
            const start1 = performance.now();
            await fileService.findTemplates();
            results.templateDiscovery = performance.now() - start1;
            
            // Test 2: State management performance
            const stateService = new StateService();
            const start2 = performance.now();
            for (let i = 0; i < 100; i++) {
              await stateService.getTemplateStatus(`template_${i}.sql`);
            }
            results.stateQueries = performance.now() - start2;
            
            // Test 3: Database query performance
            const db = new DatabaseService({ connectionString: process.env.DATABASE_URL });
            const start3 = performance.now();
            const promises = [];
            for (let i = 0; i < 50; i++) {
              promises.push(db.executeSQL('SELECT 1'));
            }
            await Promise.all(promises);
            results.databaseQueries = performance.now() - start3;
            await db.destroy();
            
            // Test 4: Migration generation performance
            const migrationBuilder = new MigrationBuilder();
            const start4 = performance.now();
            for (let i = 0; i < 10; i++) {
              await migrationBuilder.generateMigration({
                name: `test_${i}`,
                content: 'CREATE TABLE test (id INT);',
                hash: `hash_${i}`
              }, { lastTimestamp: '20240101000000' });
            }
            results.migrationGeneration = performance.now() - start4;
            
            // Output results
            console.log(JSON.stringify(results, null, 2));
            
            // Check for regressions (example thresholds)
            const thresholds = {
              templateDiscovery: 100,     // ms
              stateQueries: 500,          // ms
              databaseQueries: 1000,      // ms
              migrationGeneration: 200    // ms
            };
            
            let hasRegression = false;
            for (const [key, value] of Object.entries(results)) {
              if (value > thresholds[key]) {
                console.error(`Performance regression in ${key}: ${value}ms (threshold: ${thresholds[key]}ms)`);
                hasRegression = true;
              }
            }
            
            process.exit(hasRegression ? 1 : 0);
          }
          
          runBenchmarks().catch(console.error);
          EOF
          
          node perf-test.js

      - name: Save performance results
        if: always()
        run: |
          echo "Performance test completed at $(date)" > performance-report.txt
          
      - name: Upload performance artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-test-artifacts
          path: performance-report.txt
          retention-days: 30

  # Job 4: Report results and notify
  report:
    name: Report Test Results
    needs: [setup, database-test, performance-test]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Generate test summary
        run: |
          echo "## Database Testing Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test ID:** ${{ needs.setup.outputs.test-id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check test results
          if [ "${{ needs.database-test.result }}" == "success" ]; then
            echo "✅ **Database Tests:** Passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Database Tests:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.performance-test.result }}" == "success" ]; then
            echo "✅ **Performance Tests:** Passed" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.performance-test.result }}" == "skipped" ]; then
            echo "⏭️ **Performance Tests:** Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ **Performance Tests:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "Test artifacts have been uploaded and are available for download." >> $GITHUB_STEP_SUMMARY

      - name: Notify on failure (Slack)
        if: failure() && github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            Database Testing Failed!
            Workflow: ${{ github.workflow }}
            Test ID: ${{ needs.setup.outputs.test-id }}
            Branch: ${{ github.ref }}
            Commit: ${{ github.sha }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const outcome = '${{ needs.database-test.result }}';
            const testId = '${{ needs.setup.outputs.test-id }}';
            
            const body = `## Database Testing Results
            
            **Test ID:** ${testId}
            **Status:** ${outcome === 'success' ? '✅ Passed' : '❌ Failed'}
            
            Database integration tests have ${outcome === 'success' ? 'passed' : 'failed'}.
            Check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
        continue-on-error: true